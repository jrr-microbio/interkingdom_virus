---
title: "3.4_interkingdom_commands"
author: "Josué Rodríguez-Ramos"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r load libs, ECHO=F}
library(indicspecies)
library(clusterProfiler)
library(gridExtra)
library(tidyr)
library(ggplot2)
library(edgeR)
library(stringr)
library(rstatix)
library(ggpubr)
library(wesanderson)
library(tibble)
library(mctoolsr)
library(ggnewscale)
library(dplyr)
library(reshape2)
library(tidyverse)
library(reticulate)
library(forcats)
library(patchwork)
library(DESeq2)
library(ashr)
library(ggrepel)
library(pls)
library(pheatmap)
library(UpSetR)
library(vegan)
library(cowplot)

```


```{r Mapping stats, viral accumulation curves, and richness calculations per method}

setwd('/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/')

### Calculate species accumulation curve, richness and shannon's H (a helpful guide: https://kembellab.ca/r-workshop/biodivR/SK_Biodiversity_R.html , and https://rpubs.com/an-bui/vegan-cheat-sheet)

#Before going into richness and others, going to just really quickly plot out the read mapping statistics that i have.

# Read in the data
mapping_stats = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/read_mapping_statistics.csv", header = TRUE, sep=",")

# Reorder the factor levels
mapping_stats$Type = factor(mapping_stats$Type, levels = c("DNA Virome", "EukFloat", "Bacterial", "RNA Virome", "BulkMetaT", "PolyA"))

# Create the plots
boxplot_readsused = ggplot(mapping_stats, aes(x = Type, y = ReadsUsed)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = Type), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Total reads") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) +
  scale_color_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) + 
  theme(legend.position = "none")

boxplot_mapping = ggplot(mapping_stats, aes(x = Type, y = ReadsMapped)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = Type), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Total reads mapped") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) +
  scale_color_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) + 
  theme(legend.position = "none")

boxplot_normalized = ggplot(mapping_stats, aes(x = Type, y = ReadsNormalized)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = Type), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Normalized counts (Reads mapped / Total reads)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) +
  scale_color_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) + 
  theme(legend.position = "none")

# Arrange the plots
mappingstats_plots = grid.arrange(boxplot_readsused, boxplot_mapping, boxplot_normalized, ncol = 3)

#ggsave(mappingstats_plots, file="FigureX_MappingStats.pdf", height=6, width=14)

#Now lets overlay moisture just to see.
boxplot_readsused_moist = ggplot(mapping_stats, aes(x = Type, y = ReadsUsed)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = sample_moisture), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Total reads") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) +  
  scale_color_manual(values=c( "higher" = "#5cb5e1", "intermediate" = "#f5cfbe", "lower" = "#d46d93")) + 
  theme(legend.position = "none")

boxplot_mapping_moist = ggplot(mapping_stats, aes(x = Type, y = ReadsMapped)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = sample_moisture), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Total reads mapped") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) +  
  scale_color_manual(values=c( "higher" = "#5cb5e1", "intermediate" = "#f5cfbe", "lower" = "#d46d93")) + 
  theme(legend.position = "none")

boxplot_normalized_moist = ggplot(mapping_stats, aes(x = Type, y = ReadsNormalized)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = sample_moisture), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Normalized counts (Reads mapped / Total reads") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("Bacterial" = "#54bc37", "EukFloat" = "#f0704a", "DNA Virome" = "#73c5f6", "BulkMetaT" = "#fedd8d", "RNA Virome" = "#c5b4c5", "PolyA" = "#8ba494")) +  
  scale_color_manual(values=c( "higher" = "#5cb5e1", "intermediate" = "#f5cfbe", "lower" = "#d46d93")) + 
  theme(legend.position = "none")

mappingstats_plots_moist = grid.arrange(boxplot_readsused_moist, boxplot_mapping_moist, boxplot_normalized_moist, ncol = 3)

#For the richness, i made up some python code to take in the clusters output from the checkV and make a proper OTU-like table. I'm going to read that output OTU table now. This is better than just mapping either metaT or metaG because we have true counts data for each vOTU and whether it was or wasn't present in a sample!
mg_bacterial = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_DNA_bacteria_871.csv", header = T, sep=",", row.names = 1)

mg_eukfloat = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_DNA_EukFloat_3757.csv", header = T, sep=",", row.names = 1)

mg_virome = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_DNA_virome_14124.csv", header = T, sep=",", row.names = 1)

mt_bulk = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_RNA_bulkMetaT_4035.csv", header = T, sep=",", row.names = 1)

mt_virome = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_RNA_virome_3892.csv", header = T, sep=",", row.names = 1)

mt_polya = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_RNA_polyA_375.csv", header = T, sep=",", row.names = 1)

#Now I want to make accum curves for each of these individually, and then plot all of them in the same plot as well.

accumcurve_mg_bacterial = specaccum(t(mg_bacterial), method = "random", permutations=500)
accumcurve_mg_eukfloat = specaccum(t(mg_eukfloat), method = "random", permutations=500)
accumcurve_mg_virome = specaccum(t(mg_virome), method = "random", permutations=500)
#
accumcurve_mt_bulk = specaccum(t(mt_bulk), method = "random", permutations=500)
accumcurve_mt_virome = specaccum(t(mt_virome), method = "random", permutations=500)
accumcurve_mt_polya = specaccum(t(mt_polya), method = "random", permutations=500)

# Function to compute slope
compute_slope = function(accum_curve) {
  fit = lm(accum_curve$richness ~ accum_curve$sites)
  slope = coef(fit)[2]
  return(slope)
}

# Calculate slopes
slope_mg_bacterial = compute_slope(accumcurve_mg_bacterial)
slope_mg_eukfloat = compute_slope(accumcurve_mg_eukfloat)
slope_mg_virome = compute_slope(accumcurve_mg_virome)
slope_mt_bulk = compute_slope(accumcurve_mt_bulk)
slope_mt_virome = compute_slope(accumcurve_mt_virome)
slope_mt_polya = compute_slope(accumcurve_mt_polya)

# Print the slopes
cat("Slope for mg_bacterial:", slope_mg_bacterial, "\n")
cat("Slope for mg_eukfloat:", slope_mg_eukfloat, "\n")
cat("Slope for mg_virome:", slope_mg_virome, "\n")
cat("Slope for mt_bulk:", slope_mt_bulk, "\n")
cat("Slope for mt_virome:", slope_mt_virome, "\n")
cat("Slope for mt_polya:", slope_mt_polya, "\n")

# Plot each species accumulation curve with slopes displayed
#pdf("viral_accumulation_curve_virome.pdf", width = 8, height = 6)
plot(accumcurve_mg_virome, add = FALSE, ci.type = "poly", col = "#73c5f6", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#73c5f6", 
     xlab = "Samples", ylab = "Number of viral populations")
text(max(accumcurve_mg_virome$sites), max(accumcurve_mg_virome$richness), labels = paste("Slope DNA virome:", round(slope_mg_virome, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the second plot as a PDF
#pdf("viral_accumulation_curve_eukfloat.pdf", width = 8, height = 6)
plot(accumcurve_mg_eukfloat, add = FALSE, ci.type = "poly", col = "#f0704a", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#f0704a")
text(max(accumcurve_mg_eukfloat$sites), max(accumcurve_mg_eukfloat$richness), labels = paste("Slope DNA EukFloat:", round(slope_mg_eukfloat, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the third plot as a PDF
#pdf("viral_accumulation_curve_bacterial.pdf", width = 8, height = 6)
plot(accumcurve_mg_bacterial, add = FALSE, ci.type = "poly", col = "#54bc37", lwd = 4, ci = 0.2, ci.lty = 1, ci.col = "#54bc37")
text(max(accumcurve_mg_bacterial$sites), max(accumcurve_mg_bacterial$richness), labels = paste("Slope DNA bacterial:", round(slope_mg_bacterial, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the fourth plot as a PDF
#pdf("viral_accumulation_curve_mt_bulk.pdf", width = 8, height = 6)
plot(accumcurve_mt_bulk, add = FALSE, ci.type = "poly", col = "#fedd8d", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#fedd8d")
text(max(accumcurve_mt_bulk$sites), max(accumcurve_mt_bulk$richness), labels = paste("Slope RNA bulk:", round(slope_mt_bulk, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the fifth plot as a PDF
#pdf("viral_accumulation_curve_mt_virome.pdf", width = 8, height = 6)
plot(accumcurve_mt_virome, add = FALSE, ci.type = "poly", col = "#c5b4c5", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#c5b4c5")
text(max(accumcurve_mt_virome$sites), max(accumcurve_mt_virome$richness), labels = paste("Slope RNA virome:", round(slope_mt_virome, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the sixth plot as a PDF
#pdf("viral_accumulation_curve_mt_polya.pdf", width = 8, height = 6)
plot(accumcurve_mt_polya, add = FALSE, ci.type = "poly", col = "#8ba494", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#8ba494")
text(max(accumcurve_mt_polya$sites), max(accumcurve_mt_polya$richness), labels = paste("Slope RNA polyA:", round(slope_mt_polya, 3)), adj = 1)
#dev.off()  # Close the PDF device
#Perfect. Solid supplementary figure.

#Now i want to make the richness / counts of each vOTU across each dataset. Using the geaParser, i'm able to discriminate between reads mapped to coding / template strand and those mapping to non-coding / expressed strand of the RNA seq data. I now have full vOTU tables that represent "counts" of each vOTU per sample per data method. Reading these in.

mg_bacterial_counts = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_richness/1xdepth_75cov_filtered_coverM_counts_DNA_Bacterial_861.txt", header = T, sep="\t", row.names = 1)

mg_eukfloat_counts = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_richness/1xdepth_75cov_filtered_coverM_counts_DNA_EukFloat_3612.txt", header = T, sep="\t", row.names = 1)

mg_virome_counts = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_richness/1xdepth_75cov_filtered_coverM_counts_DNA_Virome_13735.txt", header = T, sep="\t", row.names = 1)

mg_virome_counts = mg_virome_counts %>%
  select(-c(SM1001_MG_virome, SM1002_MG_virome)) #these two samples are pretty bad outliers because they did not get much viruses. pulling them out.

mt_bulk_counts = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_richness/vOTU_output_abundance_counts_parsed_RNA_bulkMetaT_3862.tsv", header = T, sep="\t", row.names = 1)

mt_virome_counts = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_richness/vOTU_output_abundance_counts_parsed_RNA_Virome_3787.tsv", header = T, sep="\t", row.names = 1)

mt_polya_counts = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/viral_richness/vOTU_output_abundance_counts_parsed_RNA_PolyA_372.tsv", header = T, sep="\t", row.names = 1)

# Define a function to calculate richness, diversity, and evenness
calculate_metrics = function(otu_table, method_name) {
  richness = colSums(otu_table > 0)
  shannon = diversity(t(otu_table), index = "shannon")
  pielou = shannon / log(richness)
  tibble(
    sample_id = colnames(otu_table),
    richness = richness,
    shannons = shannon,
    pielous = pielou,
    method = method_name
  )
}

# Calculate metrics for each OTU table
methods = list(mg_bacterial_counts = "bacterial",
                mg_eukfloat_counts = "eukfloat",
                mg_virome_counts = "virome",
                mt_bulk_counts = "mt_bulk",
                mt_virome_counts = "mt_virome",
                mt_polya_counts = "mt_polya")

metrics_list = lapply(names(methods), function(otu_table_name) {
  calculate_metrics(get(otu_table_name), methods[[otu_table_name]])
})

# Combine all metrics into a single data frame
metrics_combined = bind_rows(metrics_list)

# Moisture data
sample_moisture = data.frame(
  sample = c("SM1001", "SM1002", "SM1027", "SM1028", "SM1029","SM1003", "SM1026", "SM1030", "SM1050", "SM1000", "SM1004", "SM1005", "SM1031"), moisture = c(rep("Low", 5), rep("Intermediate", 4), rep("High", 4)))

# Add moisture data to metrics_combined
metrics_combined = metrics_combined %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(sample_moisture, by = c("base_sample_id" = "sample")) %>%
  select(-base_sample_id)

# Define custom colors
custom_colors = c("High" = "#698934", "Intermediate" = "#f5cfbe", "Low" = "#d46d93")

# Create Richness plot
richness_plot = ggplot(metrics_combined, aes(x = method, y = richness, fill = moisture)) +
  geom_boxplot() +
  labs(title = "Richness by Method and Moisture Level", x = "Method", y = "Richness (Number of Unique OTUs)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) + 
  scale_fill_manual(values = custom_colors) + 
  facet_wrap(~ method, scales = "free")

#ggsave(richness_plot, file="richness_plots_v2.pdf")

# Create Shannon's Diversity Index plot
shannon_plot = ggplot(metrics_combined, aes(x = method, y = shannons, fill = moisture)) +
  geom_boxplot() +
  labs(title = "Shannon Diversity Index by Method and Moisture Level", x = "Method", y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) + 
  scale_fill_manual(values = custom_colors) #+ 
  #facet_wrap(~ method, scales = "free")

#ggsave(shannon_plot, file="shannon_plots.pdf")

# Create Pielou's Evenness Index plot
pielou_plot = ggplot(metrics_combined, aes(x = method, y = pielous, fill = moisture)) +
  geom_boxplot() +
  labs(title = "Pielou's Evenness Index by Method and Moisture Level", x = "Method", y = "Pielou's Evenness Index") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) + 
  scale_fill_manual(values = custom_colors) #+ 
  #facet_wrap(~ method, scales = "free")

#ggsave(pielou_plot, file="pielou_plots.pdf")
       
# Print the plots
print(richness_plot)
print(shannon_plot)
print(pielou_plot)

# Perform ANOVA and Kruskal-Wallis tests
categories = unique(metrics_combined$method)

kruskal_results = list()

for (cat in categories) {
  cat_data = filter(metrics_combined, method == cat)
  
  # Perform Kruskal-Wallis test for Richness, Shannon's, and Pielou's
  kw_richness_result = kruskal.test(richness ~ moisture, data = cat_data)
  kw_shannon_result = kruskal.test(shannons ~ moisture, data = cat_data)
  kw_pielou_result = kruskal.test(pielous ~ moisture, data = cat_data)
  
  # Perform pairwise Wilcoxon test if significant
  pairwise_richness = if(kw_richness_result$p.value < 0.05) { 
    pairwise.wilcox.test(cat_data$richness, cat_data$moisture, p.adjust.method = "BH") 
  } else { 
    NULL 
  }
  
  pairwise_shannon = if(kw_shannon_result$p.value < 0.05) { 
    pairwise.wilcox.test(cat_data$shannons, cat_data$moisture, p.adjust.method = "BH") 
  } else { 
    NULL 
  }
  
  pairwise_pielou = if(kw_pielou_result$p.value < 0.05) { 
    pairwise.wilcox.test(cat_data$pielous, cat_data$moisture, p.adjust.method = "BH") 
  } else { 
    NULL 
  }
  
  kruskal_results[[cat]] = list(
    richness = list(kruskal = kw_richness_result, pairwise = pairwise_richness),
    shannons = list(kruskal = kw_shannon_result, pairwise = pairwise_shannon),
    pielous = list(kruskal = kw_pielou_result, pairwise = pairwise_pielou)
  )
}

# Print results (optional)
print(kruskal_results)

#
# Perform Kruskal-Wallis tests but across method types, not moisture within methods. Going to remove richness because that one isn't exactly a fair comparison because different methods can yield differen communities (and fractions) so comparing the numbers is meaningless.

kruskal_results = list()

# Perform Kruskal-Wallis test for Shannon's and Pielou's
kw_shannon_result = kruskal.test(shannons ~ method, data = metrics_combined)
kw_pielou_result = kruskal.test(pielous ~ method, data = metrics_combined)

# Perform pairwise Wilcoxon test if significant
pairwise_shannon = if(kw_shannon_result$p.value < 0.05) { 
  pairwise.wilcox.test(metrics_combined$shannons, metrics_combined$method, p.adjust.method = "BH") 
} else { 
  NULL 
}

pairwise_pielou = if(kw_pielou_result$p.value < 0.05) { 
  pairwise.wilcox.test(metrics_combined$pielous, metrics_combined$method, p.adjust.method = "BH") 
} else { 
  NULL 
}

kruskal_results = list(
  shannons = list(kruskal = kw_shannon_result, pairwise = pairwise_shannon),
  pielous = list(kruskal = kw_pielou_result, pairwise = pairwise_pielou)
)

# Access results
print(kruskal_results)

#One last thing i want to do here before moving on. I want to use normalized counts data and just plop them over and look at the seasonal patterns.

mg_bacterial_counts_rel = mg_bacterial_counts %>% 
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

mg_eukfloat_counts_rel = mg_eukfloat_counts %>% 
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

mg_virome_counts_rel = mg_virome_counts %>% 
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

mt_bulk_counts_rel = mt_bulk_counts %>% 
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

mt_virome_counts_rel = mt_virome_counts %>% 
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

mt_polya_counts_rel = mt_polya_counts %>% 
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

colnames(mg_bacterial_counts_rel) = sub("^(SM10\\d+).*", "\\1", colnames(mg_bacterial_counts_rel))
colnames(mg_eukfloat_counts_rel) = sub("^(SM10\\d+).*", "\\1", colnames(mg_eukfloat_counts_rel))
colnames(mg_virome_counts_rel) = sub("^(SM10\\d+).*", "\\1", colnames(mg_virome_counts_rel))
colnames(mt_bulk_counts_rel) = sub("^(SM10\\d+).*", "\\1", colnames(mt_bulk_counts_rel))
colnames(mt_virome_counts_rel) = sub("^(SM10\\d+).*", "\\1", colnames(mt_virome_counts_rel))
colnames(mt_polya_counts_rel) = sub("^(SM10\\d+).*", "\\1", colnames(mt_polya_counts_rel))

#Read in the metadata for the samples. 
sample_metadata = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/supplementary_tables/TableSX_sample_metadata.csv")

mg_bacterial_counts_rel_long = mg_bacterial_counts_rel %>%
  rownames_to_column(var="genome_id") %>%
  pivot_longer(-genome_id, names_to = "sample", values_to = "abundance") %>%
  inner_join(sample_metadata, by = c("sample" = "sample"))

# Summarize abundance by "water_category_soft" for mg_bacterial_counts_rel
mg_bacterial_summary = mg_bacterial_counts_rel_long %>%
  group_by(water_category_soft) %>%
  summarize(total_abundance = sum(abundance, na.rm = TRUE))

```

```{r Upset plots and quality comparisons per data stream}
#For this otu table, i re-clustered all 27k vOTUs from the Single assemblies that went into the figures above.

upset_otu_table = read.csv(file="/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/23117_otu_table_filtered_reordered_forUpsets.csv", header=T, sep=',', row.names = 1)

#Ok so now I am really interested in trying to find the overlap of these vOTUs across the samples (i.e., how many are unique per data type / redundant). Going to just aggregate all of the vOTUs per sample-type first. Note again: This is not including the co-assembly unique vOTUs. Those i will just implement into the ecology portion of the paper.

#Now I'm going to split them up into multiple data streams.
mg_bacterial_clust = upset_otu_table %>%
  select(1:8)

mg_eukfloat_clust = upset_otu_table %>%
  select(9:21)

mg_virome_clust = upset_otu_table %>%
  select(22:34)

mt_bulk_clust = upset_otu_table %>%
  select(35:47)

mt_virome_clust = upset_otu_table %>%
  select(48:60)

mt_polya_clust = upset_otu_table %>%
  select(61:73)

#Now, i'm converting this into presence absence. The question is whether the virus OTU is detected across methods or not, not how many of them are within each (i.e., 1x vOTU twice). 

DNA_bacterial_agg = mg_bacterial_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(DNA_bacterial_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, DNA_bacterial_agg)

DNA_eukfloat_agg = mg_eukfloat_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(DNA_eukfloat_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, DNA_eukfloat_agg)

DNA_virome_agg = mg_virome_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(DNA_virome_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, DNA_virome_agg)

RNA_bulk_agg = mt_bulk_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(RNA_bulk_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, RNA_bulk_agg)

sum(RNA_bulk_agg$RNA_bulk_agg)

RNA_virome_agg = mt_virome_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(RNA_virome_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, RNA_virome_agg)

sum(RNA_bulk_agg$RNA_bulk_agg)

RNA_polya_agg = mt_polya_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(RNA_polya_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, RNA_polya_agg)

aggregated_vOTUs = DNA_bacterial_agg %>%
  left_join(DNA_eukfloat_agg, by = "virus_id") %>%
  left_join(DNA_virome_agg, by = "virus_id") %>%
  left_join(RNA_polya_agg, by = "virus_id") %>%
  left_join(RNA_virome_agg, by = "virus_id") %>%
  left_join(RNA_bulk_agg, by = "virus_id")

#write.csv(aggregated_vOTUs, file="vPop_table_pres_abs_newer.csv")

aggregated_vOTUs_2=aggregated_vOTUs %>%
  column_to_rownames("virus_id")

# Ensure all columns are numeric
aggregated_vOTUs_2[] = lapply(aggregated_vOTUs_2, as.numeric)

upset_plot = upset(aggregated_vOTUs_2, 
      sets = colnames(aggregated_vOTUs_2),
      keep.order = T,
      order.by = "freq")

#pdf("upset_plot.pdf", width = 10, height = 8)

# Produce and save the UpSet plot
upset(
  aggregated_vOTUs_2, 
  sets = colnames(aggregated_vOTUs_2),
  keep.order = TRUE,
  order.by = "freq"
)

# Close the PDF device
#dev.off()


#Beautiful. There is the upset plot done! Now, i can see the quantities of the viruses, but i want to compare the quality as well


##########################################################

datastream_metadat = read.csv(file="/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/vOTUs_per_data_stream_stats.csv", header=T, sep=',')

quality_table = datastream_metadat %>%
  select(-c(2, 4:7, 11:17, 21))

# Define the desired order of sample types
sampletype_order = c("MG_virome", "MG_EukFloat", "MG_bacterial", "MT_Bulk", "MT_virome", "PolyA_RNA")

qual_colors = c("#73c5f6", "#bde673", "#8b9462", "#c5b4c5", "#ff7373")

# Define the desired order of checkv_quality
checkv_quality_order = c("Complete", "High-quality", "Medium-quality", "Low-quality", "Not-determined")

quality_table_agg_df = quality_table %>%
  mutate(sampletype = factor(sampletype, levels = sampletype_order),
         checkv_quality = factor(checkv_quality, levels = checkv_quality_order)) %>%
  group_by(sampletype, checkv_quality) %>%
  summarise(count = n()) %>%
  ungroup()

# Create the proportional plot
proportional_plot = ggplot(quality_table_agg_df, aes(x = sampletype, y = count, fill = checkv_quality)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = qual_colors) +
  labs(title = "Proportional Distribution of vOTUs per Sample Type and CheckV Quality",
       x = "Sample Type",
       y = "Proportion of vOTUs",
       fill = "CheckV Quality") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

proportional_plot

# Create the count plot
count_plot = ggplot(quality_table_agg_df, aes(x = sampletype, y = count, fill = checkv_quality)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = qual_colors) +
  labs(title = "Count of vOTUs per Sample Type and CheckV Quality",
       x = "Sample Type",
       y = "Count of vOTUs",
       fill = "CheckV Quality") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

count_plot

# Arrange the plots side by side
combined_plot = arrangeGrob(proportional_plot, count_plot, ncol = 2)
combined_plot
# Save the combined plots to a PDF file
#ggsave("vOTUs_quality_distributions.pdf", combined_plot, width = 14, height = 7, units = "in")

#Now lets plot the lenghts.

datastream_colors = c("#54bc00", "#f0704a", "#73c5f6", "#fedd8d", "#8ba494", "#c5b4c5")

# Create the boxplot
virus_length_plot = ggplot(quality_table, aes(x = sampletype, y = virus_length)) +
  geom_jitter(aes(color=sampletype)) +
  scale_color_manual(values = datastream_colors) +
  labs(title = "Distribution of Virus Length per Sample Type",
       x = "Sample Type",
       y = "Virus Length") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")

virus_length_plot
#ggsave("vOTUs_length_distributions.pdf", virus_length_plot, width = 14, height = 7, units = "in")

#I like it but want to facet wrap DNA and RNA viruses.

# Categorize sample types into the two desired groups
quality_table = quality_table %>%
  mutate(group = case_when(
    sampletype %in% c("MG_virome", "MG_bacterial", "MG_EukFloat") ~ "Group 1",
    sampletype %in% c("MT_Bulk", "PolyA_RNA", "MT_virome") ~ "Group 2",
    TRUE ~ "Other"
  ))

# Create the boxplot
virus_length_plot = ggplot(quality_table, aes(x = sampletype, y = virus_length)) +
  geom_jitter(aes(color=sampletype)) +
  scale_color_manual(values = datastream_colors) +
  labs(title = "Distribution of Virus Length per Sample Type",
       x = "Sample Type",
       y = "Virus Length") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") +
  facet_wrap(~ group, scales = "free")

virus_length_plot
#ggsave("vOTUsgroup#ggsave("vOTUs_length_distributions.pdf", virus_length_plot, width = 14, height = 7, units = "in")

# Update the factor levels for sampletype
quality_table$sampletype = factor(quality_table$sampletype, levels = c("MG_virome", "MG_EukFloat", "MG_bacterial", "MT_virome", "MT_Bulk", "PolyA_RNA"))

datastream_colorslen = c("#73c5f6", "#f0704a", "#54bc00", "#c5b4c5", "#fedd8d", "#8ba494")

# First density plot
density_plot1 = ggplot(quality_table %>% filter(group == "Group 1"), aes(x = virus_length, fill = sampletype)) +
  geom_density(alpha = 0.5) +
  scale_fill_manual(values = datastream_colorslen) +
  labs(title = "Density of Virus Length for Group 1",
       x = "Virus Length",
       y = "Density") +
  theme_minimal()

density_plot1

#ggsave("vOTU_distribution_plot_DNA.pdf", density_plot1, width = 14, height = 7, units = "in")

# Second density plot
density_plot2 = ggplot(quality_table %>% filter(group == "Group 2"), aes(x = virus_length, fill = sampletype)) +
  geom_density(alpha = 0.5) +
  scale_fill_manual(values = datastream_colorslen) +
  labs(title = "Density of Virus Length for Group 2",
       x = "Virus Length",
       y = "Density") +
  theme_minimal()

density_plot2

#ggsave("vOTU_distribution_plot_RNA.pdf", density_plot2, width = 14, height = 7, units = "in")


#Now lets make the boxplots of the yield nanograms, the soil weight utilized, and the sample sizes.
manifest_metadat = read.table(file="/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/sample_metadata_dna_weight_seqs.csv", sep = ",", header=T)

# Reorder the factor levels for the specified columns
manifest_metadat$data_stream = factor(manifest_metadat$data_stream, levels = c("DNA Virome", "DNA Fungal", "DNA Bacterial", "RNA Virome", "RNA Bulk", "RNA PolyA"))

manifest_metadat$normalized_yield = manifest_metadat$yield_ng / manifest_metadat$soil_extracted_g

# Define color mapping
datastream_colors = c("DNA Virome" = "#73c5f6", "DNA Fungal" = "#f0704a", "DNA Bacterial" = "#54bc37", "RNA Bulk" = "#fedd8d", "RNA PolyA" = "#8ba494", "RNA Virome" = "#c5b4c5")

water_category_colors = c("higher" = "#5cb5e1", "intermediate" = "#ffcdbd", "lower" = "#e66294")

# Yield Plot
yieldplot = ggplot(manifest_metadat, aes(x = data_stream, y = normalized_yield)) +
  geom_boxplot(aes(color = data_stream)) +
  geom_jitter(aes(color = water_category_soft), width = 0.2, size = 2, alpha = 0.8) +
  labs(title = "Yield (ng) by Data Stream",
       x = "Data Stream", 
       y = "Yield (ng)") +
  theme_minimal() +
  scale_color_manual(values = c(datastream_colors, water_category_colors)) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5))  # Centering the title

yieldplot

# Sample Size Plot
samplesizeplot = ggplot(manifest_metadat, aes(x = data_stream, y = soil_extracted_g)) +
  geom_boxplot(aes(color = data_stream)) +
  geom_jitter(aes(color = water_category_soft), width = 0.2, size = 2, alpha = 0.8) +
  labs(title = "Sample Size by Data Stream",
       x = "Data Stream", 
       y = "Sample size (grams of soil)") +
  theme_minimal() +
  scale_color_manual(values = c(datastream_colors, water_category_colors)) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5))  # Centering the title
samplesizeplot

# Number of Reads Plot
numreadsplot = ggplot(manifest_metadat, aes(x = data_stream, y = sample_size_qcnumreads)) +
  geom_boxplot(aes(color = data_stream)) +
  geom_jitter(aes(color = water_category_soft), width = 0.2, size = 2, alpha = 0.8) +
  labs(title = "Sample Size by Data Stream",
       x = "Data Stream", 
       y = "Number of reads") +
  theme_minimal() +
  scale_color_manual(values = c(datastream_colors, water_category_colors)) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5))  # Centering the title
numreadsplot

# ggsave(combined_plot, file = "sample_metadata_boxplots.pdf", height = 9, width = 4)

# RNA Contamination Plot
percRNAcontplot = ggplot(manifest_metadat, aes(x = data_stream, y = perc_removed_ribosomal)) +
  geom_boxplot(aes(color = data_stream)) +
  geom_jitter(aes(color = water_category_soft), width = 0.2, size = 2, alpha = 0.8) +
  labs(title = "rRNA contamination per data stream",
       x = "Data Stream", 
       y = "Percent RNA contamination") +
  theme_minimal() +
  scale_color_manual(values = c(datastream_colors, water_category_colors)) +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5))  # Centering the title
percRNAcontplot
#ggsave(percRNAcontplot, file="percentrRNAcontam_boxplots.pdf")

combined_plot = ggarrange(yieldplot, samplesizeplot, numreadsplot, percRNAcontplot,
                           labels = c("A", "B", "C", "D"),
                           ncol = 2, nrow = 2)

combined_plot
#ggsave(combined_plot, file="combo_quality_boxplots.pdf", height = 9, width = 7)


#ONe last thing, lets make an nmds with the upset plot clustering data.

upset_otu_table = read.csv(file="/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/data_stream_comparisons/23117_otu_table_filtered_reordered_forUpsets_nozero.csv", header=T, sep=',', row.names = 1)

upset_otu_table_new = upset_otu_table + 1  # Adding 1 to avoid log(0) issue
upset_otu_table_log = log(upset_otu_table_new)

upset_otu_table_DNA = upset_otu_table %>%
  select(1:33)
  
upset_otu_table_RNA = upset_otu_table %>%
  select(34:71)
  
# 3. Create a metadata file that identifies your sample types
sample_types = colnames(upset_otu_table_new)
sample_types = data.frame(
  Sample = sample_types,
  Type = sapply(strsplit(sample_types, "_"), function(x) paste(x[2], x[3], sep = "_"))
)


# 4. Perform the NMDS analysis
nmds_dna = metaMDS(t(upset_otu_table_DNA), distance = "bray", k = 2)
nmds_rna = metaMDS(t(upset_otu_table_RNA), distance = "bray", k = 2)
stressplot(nmds_dna)
stressplot(nmds_rna)

# 5. Prepare data for plotting
nmds_data_dna = as.data.frame(nmds_dna$points)
nmds_data_dna$Sample = rownames(nmds_data_dna)
nmds_data_dna = merge(nmds_data_dna, sample_types, by = "Sample")

nmds_data_rna = as.data.frame(nmds_rna$points)
nmds_data_rna$Sample = rownames(nmds_data_rna)
nmds_data_rna = merge(nmds_data_rna, sample_types, by = "Sample")

# 6. Plot the NMDS result using ggplot2
ggplot(nmds_data_dna, aes(MDS1, MDS2, color = Type)) +
  geom_point(size = 4) +
  geom_text_repel(aes(label = Sample), size = 3, box.padding = 0.35, point.padding = 0.5) +  # size is set to 3 for small text
  theme_minimal() +
  labs(title = "NMDS of DNA vOTU Table", x = "NMDS1", y = "NMDS2") +
  theme(legend.title = element_blank())

# NMDS of RNA vOTU Table with sample IDs as labels
ggplot(nmds_data_rna, aes(MDS1, MDS2, color = Type)) +
  geom_point(size = 4) +
  geom_text_repel(aes(label = Sample), size = 3, box.padding = 0.35, point.padding = 0.5) +  # size is set to 3 for small text
  theme_minimal() +
  labs(title = "NMDS of RNA vOTU Table", x = "NMDS1", y = "NMDS2") +
  theme(legend.title = element_blank())

#ew. and also no- no distinction.




##One last thing here. lets compare the vOTU lengths of the viruses that are shared across at least 2 preparation methods. 

overlapping_vOTUs = read.csv("overlapping_vOTUs_to_parse.csv", header=T)

# Transforming the data
# Transform the data
long_format_overlaps = overlapping_vOTUs %>%
  # Combine representative_id with clustered_votus into one string
  mutate(all_viruses = paste(representative_id, clustered_votus, sep = ",")) %>%
  # Split into separate virus entries
  separate_rows(all_viruses, sep = ",") %>%
  # Remove duplicates to ensure unique virus entries
  distinct(all_viruses, representative_id, cluster) %>%
  # Select only the virus and group (cluster) columns
  select(virus = all_viruses, group = cluster) %>%
  # Ungroup the dataframe to finalize
  ungroup()

#write.csv(long_format_overlaps, file="long_format_overlaps.csv")

#Did a bunch of merging outside of R because there were a few things that needed tweaking re: IDs. 

# Read the updated CSV file
long_format_overlaps_updated = read_csv("long_format_overlaps_v2.csv")

# Calculate the average lengths within each cluster and genome_type
avg_lengths = long_format_overlaps_updated %>%
  group_by(group, genome_type, sample_origin) %>%
  summarize(avg_length = mean(length)) %>%
  ungroup()

# Determine the sample_origin with the longest average length in each cluster and genome_type
longest_avg = avg_lengths %>%
  group_by(group, genome_type) %>%
  filter(avg_length == max(avg_length)) %>%
  ungroup()

# Calculate the proportion of clusters where each sample_origin has the highest average length per genome_type
proportions = longest_avg %>%
  group_by(genome_type, sample_origin) %>%
  summarize(count = n()) %>%
  mutate(proportion = count / sum(count)) %>%
  ungroup()

print(proportions)

```

```{r Consolidated database: Loading data and normalizing}

#Let's clean this up from the last stuff. 

variables_to_keep4 = c("datastream_metadat", "sample_metadata") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep4)) #clean out the environment - keeping the metadata

#Now we're going to start working with the fully de-replicated database across all data methods. I mapped these three ways. 1. DNA vOTUs to bulk metaT (dna expression) 2. DNA vOTUs to dna virome (dna abundance) 3. RNA vOTUs to bulk metaT (rna abundance and expression). The latter file (3) i then used geaParser to determine if reads mapped to template strand (abundance) or non-template strand (expression). These are only ssRNA + or - viruses so these should be accurate. I did get a handful of clobbers that said certain vOTUs were expressed but not abundant - i removed those small fraction of vOTUs because i think those are more likely methodological detection issues that did not make the 1x depth and 75% coverage cutoff.

#DNA abundance 
counts_dna_abund = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/DNA_virome_DNA_vOTU/1xdepth_75cov_filtered_coverM_counts.txt", header = T, sep="\t") #coverM out

#Processing dna abund coverM table. This already has 1x depth cutoff and 75% coverage cutoff implemented.
relabund_dna_abund_genome = counts_dna_abund %>%
  column_to_rownames("Contig") %>%
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

#write.csv(relabund_dna_abund_genome, file="relabund_DNA_vOTU_abunds.csv")

# Sample to moisture mapping
sample_moisture = data.frame(
  sample = c("SM1001", "SM1002", "SM1027", "SM1028", "SM1029","SM1003", "SM1026", "SM1030", "SM1050", "SM1000", "SM1004", "SM1005", "SM1031"), moisture = c(rep("Low", 5), rep("Intermediate", 4), rep("High", 4)))

# Assuming relabund_dna_abund_genome is your OTU table
richness_per_sample = colSums(relabund_dna_abund_genome > 0)
shannon_diversity = diversity(t(relabund_dna_abund_genome), index = "shannon")
pielou_evenness = shannon_diversity / log(richness_per_sample)

# Convert to data frames
richness_df = data.frame(sample = names(richness_per_sample), richness = richness_per_sample)
shannon_df = data.frame(sample = names(shannon_diversity), shannon = shannon_diversity)
pielou_df = data.frame(sample = names(pielou_evenness), pielou = pielou_evenness)

# Map samples to moisture treatments
richness_df = richness_df %>%
  left_join(sample_moisture, by = "sample")

shannon_df = shannon_df %>%
  left_join(sample_moisture, by = "sample")

pielou_df = pielou_df %>%
  left_join(sample_moisture, by = "sample")

# Conduct pairwise comparisons
# Kruskal-Wallis test for Richness
richness_kruskal = richness_df %>% kruskal_test(richness ~ moisture)
print(richness_kruskal)

# Pairwise comparisons for Richness
richness_pairwise = pairwise_wilcox_test(richness ~ moisture, data = richness_df, p.adjust.method = "BH")
print(richness_pairwise)

# Kruskal-Wallis test for Shannon's Diversity Index
shannon_kruskal = shannon_df %>% kruskal_test(shannon ~ moisture)
print(shannon_kruskal)

# Pairwise comparisons for Shannon's Diversity Index
shannon_pairwise = pairwise_wilcox_test(shannon ~ moisture, data = shannon_df, p.adjust.method = "BH")
print(shannon_pairwise)

# Kruskal-Wallis test for Pielou's Evenness
pielou_kruskal = pielou_df %>% kruskal_test(pielou ~ moisture)
print(pielou_kruskal)

# Pairwise comparisons for Pielou's Evenness
pielou_pairwise = pairwise_wilcox_test(pielou ~ moisture, data = pielou_df, p.adjust.method = "BH")
print(pielou_pairwise)

# Plot Richness
dna_richness_pl = ggplot(richness_df, aes(x = moisture, y = richness)) +
  geom_boxplot(aes(fill = moisture)) +
  geom_jitter(width = 0.1, color = "black", size = 1.5) +
  labs(title = "Richness by Moisture Treatment (DNA vOTUs)",
       x = "Moisture Treatment", y = "Richness (Number of DNA vOTUs)") +
  theme_minimal() +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934"))

dna_richness_pl
#ggsave(dna_richness_pl, file="DNA_richness_consolidated.pdf")

# Plot Shannon's Diversity
dna_shannon_pl = ggplot(shannon_df, aes(x = moisture, y = shannon)) +
  geom_boxplot(aes(fill = moisture)) +
  geom_jitter(width = 0.1, color = "black", size = 1.5) +
  labs(title = "Shannon's Diversity by Moisture Treatment (DNA vOTUs)",
       x = "Moisture Treatment", y = "Shannon's Diversity Index") +
  theme_minimal() +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934"))

dna_shannon_pl
#ggsave(dna_shannon_pl, file="DNA_shannon_consolidated.pdf")

# Plot Pielou's Evenness
ggplot(pielou_df, aes(x = moisture, y = pielou)) +
  geom_boxplot(aes(fill = moisture)) +
  geom_jitter(width = 0.1, color = "black", size = 1.5) +
  labs(title = "Pielou's Evenness by Moisture Treatment",
       x = "Moisture Treatment", y = "Pielou's Evenness") +
  theme_minimal() +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934"))

#DNA expression
counts_dna_expression = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/bulk_metaT_DNA_vOTU/featureCounts_bulk_metaT_DNA_output_reverse-stranded_paired_genome.txt", header = T, sep="\t") #featureCounts out

counts_dna_expression_noZero =  counts_dna_expression %>% 
  filter(rowSums(select(., 7:19)) != 0) %>% #Remove rows where the sum of the values in columns 7 to 19 is zero - just to make the processing quicker.
  mutate(across(7:19, ~ ifelse(. < 5, 0, .))) %>% #Replace counts less than 5 with zero. Minimum of 5 counts per gene.
  filter(rowSums(select(., 7:19)) != 0) %>% #Re-filter out any gene that is completely zero
  select(-Chr, -Start, -End, -Strand) %>% #Remove a few cols.
  column_to_rownames("Geneid")

#calculate RPK
rpk_metaT_dna = ((counts_dna_expression_noZero[,2:14]*10^3)/counts_dna_expression_noZero[,1]) #note, we multiply by 10^3 here because geTMM expects kilobase pairs on lengths and featurecounts_dna_expression reports bps.
group_metaT_dna = c(rep("A",ncol(rpk_metaT_dna)))

#Just to plot out the overall expression, i'm summing these up per moisture and adding them
rpk_metaT_dna_save = rpk_metaT_dna
rpk_metaT_dna_save$low_moisture_sum = rowSums(rpk_metaT_dna[, c("SM1001", "SM1002", "SM1027", "SM1028", "SM1029")])

# Create the "intermediate_moisture_sum" column
rpk_metaT_dna_save$intermediate_moisture_sum = rowSums(rpk_metaT_dna[, c("SM1003", "SM1026", "SM1030", "SM1050")])

# Create the "high_moisture_sum" column
rpk_metaT_dna_save$high_moisture_sum = rowSums(rpk_metaT_dna[, c("SM1000", "SM1004", "SM1005", "SM1031")])

#write.csv(rpk_metaT_dna_save, file="rpk_DNA_vOTU.csv")

# Reshape the data to long format using pivot_longer
rpk_metaT_dna_long = rpk_metaT_dna_save %>%
  pivot_longer(cols = c("low_moisture_sum", "intermediate_moisture_sum", "high_moisture_sum"),
               names_to = "Moisture",
               values_to = "Expression") %>%
  filter(Expression != 0)  # Remove rows with zero values

# Sum the expression values for each sample column
sample_sums = colSums(rpk_metaT_dna[, 1:ncol(rpk_metaT_dna)])

# Create a data frame from the summed values
sample_sums_df = data.frame(Sample = names(sample_sums), 
                             TotalExpression = sample_sums)

# Define the moisture levels for each sample
sample_sums_df = sample_sums_df %>%
  mutate(Moisture = case_when(
    Sample %in% c("SM1001", "SM1002", "SM1027", "SM1028", "SM1029") ~ "Low",
    Sample %in% c("SM1003", "SM1026", "SM1030", "SM1050") ~ "Intermediate",
    Sample %in% c("SM1000", "SM1004", "SM1005", "SM1031") ~ "High",
    TRUE ~ NA_character_
  ))

# Remove any NA values in Moisture (if there are any samples not categorized)
sample_sums_df = sample_sums_df %>% filter(!is.na(Moisture))

# Create the boxplot with specified colors
overallrpkDNA = ggplot(sample_sums_df, aes(x = Moisture, y = TotalExpression, fill = Moisture)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.5) +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934")) +
  labs(title = "Boxplot of Total DNA vOTU Gene Expression (rpk) by Moisture Level",
       x = "Moisture Level",
       y = "Total Sum of Gene Expression") +
  theme_minimal()

overallrpkDNA

#ggsave(overallrpkDNA, file = "DNA_vOTU_RPK.pdf")

# Perform Kruskal-Wallis test to test for significant differences
kruskal_result = kruskal.test(TotalExpression ~ Moisture, data = sample_sums_df)
print(kruskal_result)

# Perform pairwise Wilcoxon test for pairwise comparisons if the Kruskal-Wallis test is significant
pairwise_wilcoxon_result = if(kruskal_result$p.value < 0.05) { 
  pairwise.wilcox.test(sample_sums_df$TotalExpression, sample_sums_df$Moisture, p.adjust.method = "BH") 
} else { 
  NULL 
}

print(pairwise_wilcoxon_result)


#calculate geTMM
rpk.norm_dna = DGEList(counts=rpk_metaT_dna,group=group_metaT_dna)
rpk.norm_dna = calcNormFactors(rpk.norm_dna)
geTMM_norm.counts_dna_expression.rpk_edger = as.data.frame(cpm(rpk.norm_dna))

#now aggregate these at a genome level. Bring back the ids from the original file
geTMM_dna_expression_genome = geTMM_norm.counts_dna_expression.rpk_edger %>%
  rownames_to_column("Geneid") %>%
  left_join(select(counts_dna_expression, Geneid, Chr), by = "Geneid") %>%
  select(-Geneid) %>%
  select(Chr, everything()) %>%
  group_by(Chr) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("Chr")

#write.csv(geTMM_dna_expression_genome, file="geTMM_normalized_DNA_vOTU_expression.csv")

#Lets plot out real quick total number of vOTUs that are active.

#Transpose the dataframe to have samples as rows and OTUs as columns
geTMM_dna_expression_transposed = as.data.frame(t(geTMM_dna_expression_genome))
geTMM_dna_expression_transposed = rownames_to_column(geTMM_dna_expression_transposed, "Sample")

#Join the moisture information
expressed_otus_moisture = geTMM_dna_expression_transposed %>%
  left_join(select(sample_sums_df, Sample, Moisture), by = "Sample") %>%
  pivot_longer(cols = starts_with("SM"), names_to = "OTU", values_to = "Expression") %>%
  filter(Expression > 0) %>%
  group_by(Sample, Moisture) %>%
  summarise(Expressed_OTUs = n_distinct(OTU), .groups = 'drop')

# Create the boxplot
ggplot(expressed_otus_moisture, aes(x = Moisture, y = Expressed_OTUs)) +
  geom_boxplot() +
  labs(title = "Number of Expressed OTUs by Moisture Level",
       x = "Moisture Level",
       y = "Expressed OTUs") +
  theme_minimal()

#This is the same as my overall expression patterns. This is also opposite to ruonan's trends. interesting.

#RNA abundance
counts_rna_abundance = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/bulk_metaT_RNA_vOTU/5893_genes_abundance_vOTUs.csv", header = T, sep=",") #geaParse template strand

#Processing geaParse abund table - resolving at genome level. This already has 1x depth cutoff and 75% coverage cutoff implemented.
relabund_rna_abundance_genome = counts_rna_abundance %>%
  select(-length, -gene_id) %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

relabund_rna_abundance_genome_write = relabund_rna_abundance_genome %>%
  rownames_to_column(var="genome")

#write_csv(relabund_rna_abundance_genome_write, file="relabund_rna_abundance_genome.csv")

Nonrelabund_rna_abundance_genome = counts_rna_abundance %>%
  select(-length, -gene_id) %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

# Sum the expression values for each sample column
sample_sums = colSums(Nonrelabund_rna_abundance_genome)

# Create a data frame from the summed values
sample_sums_df = data.frame(Sample = names(sample_sums), 
                             totalAbund = sample_sums)

# Define the moisture levels for each sample
sample_sums_df = sample_sums_df %>%
  mutate(Moisture = case_when(
    Sample %in% c("SM1001", "SM1002", "SM1027", "SM1028", "SM1029") ~ "Low",
    Sample %in% c("SM1003", "SM1026", "SM1030", "SM1050") ~ "Intermediate",
    Sample %in% c("SM1000", "SM1004", "SM1005", "SM1031") ~ "High",
    TRUE ~ NA_character_
  ))

# Remove any NA values in Moisture (if there are any samples not categorized)
sample_sums_df = sample_sums_df %>% filter(!is.na(Moisture))

# Create the boxplot with specified colors
RNA_vOTU_abund = ggplot(sample_sums_df, aes(x = Moisture, y = totalAbund, fill = Moisture)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.5) +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934")) +
  labs(title = "Boxplot of Total RNA vOTU Gene Abundance by Moisture Level",
       x = "Moisture Level",
       y = "Total Sum of RNA vOTU Abundance") +
  theme_minimal()

RNA_vOTU_abund

#calculate the diversity metrics
richness_per_sample = colSums(relabund_rna_abundance_genome > 0)
shannon_diversity = diversity(t(relabund_rna_abundance_genome), index = "shannon")
pielou_evenness = shannon_diversity / log(richness_per_sample)

# Convert to data frames
richness_df = data.frame(sample = names(richness_per_sample), richness = richness_per_sample)
shannon_df = data.frame(sample = names(shannon_diversity), shannon = shannon_diversity)
pielou_df = data.frame(sample = names(pielou_evenness), pielou = pielou_evenness)

# Map samples to moisture treatments
richness_df = richness_df %>%
  left_join(sample_moisture, by = "sample")

shannon_df = shannon_df %>%
  left_join(sample_moisture, by = "sample")

pielou_df = pielou_df %>%
  left_join(sample_moisture, by = "sample")

# Conduct pairwise comparisons
# Pairwise comparisons for Richness
richness_pairwise = pairwise_wilcox_test(richness ~ moisture, data = richness_df, p.adjust.method = "BH")
print(richness_pairwise)

# Pairwise comparisons for Shannon's Diversity Index
shannon_pairwise = pairwise_wilcox_test(shannon ~ moisture, data = shannon_df, p.adjust.method = "BH")
print(shannon_pairwise)

# Pairwise comparisons for Pielou's Evenness
pielou_pairwise = pairwise_wilcox_test(pielou ~ moisture, data = pielou_df, p.adjust.method = "BH")
print(pielou_pairwise)

# Plot Richness
richness_RNA_pl = ggplot(richness_df, aes(x = moisture, y = richness)) +
  geom_boxplot(aes(fill = moisture)) +
  geom_jitter(width = 0.1, color = "black", size = 1.5) +
  labs(title = "Richness by Moisture Treatment (RNA vOTUs)",
       x = "Moisture Treatment", y = "Richness (Number of RNA OTUs)") +
  theme_minimal() +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934"))

richness_RNA_pl
#ggsave(richness_RNA_pl, file = "richness_RNA.pdf")

# Plot Shannon's Diversity
shannon_RNA_pl = ggplot(shannon_df, aes(x = moisture, y = shannon)) +
  geom_boxplot(aes(fill = moisture)) +
  geom_jitter(width = 0.1, color = "black", size = 1.5) +
  labs(title = "Shannon's Diversity by Moisture Treatment (RNA vOTUs)",
       x = "Moisture Treatment", y = "Shannon's Diversity Index") +
  theme_minimal() +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934"))

shannon_RNA_pl
#ggsave(shannon_RNA_pl, file="shannon_RNA.pdf")

# Plot Pielou's Evenness
ggplot(pielou_df, aes(x = moisture, y = pielou)) +
  geom_boxplot(aes(fill = moisture)) +
  geom_jitter(width = 0.1, color = "black", size = 1.5) +
  labs(title = "Pielou's Evenness by Moisture Treatment (RNA vOTUs)",
       x = "Moisture Treatment", y = "Pielou's Evenness") +
  theme_minimal() +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934"))

#ggsave(RNA_vOTU_abund, file="RNA_vOTU_abund.pdf")

# Perform Kruskal-Wallis test to test for significant differences
kruskal_result = kruskal.test(totalAbund ~ Moisture, data = sample_sums_df)
print(kruskal_result)

# Perform pairwise Wilcoxon test for pairwise comparisons if the Kruskal-Wallis test is significant
pairwise_wilcoxon_result = if(kruskal_result$p.value < 0.05) { 
  pairwise.wilcox.test(sample_sums_df$totalAbund, sample_sums_df$Moisture, p.adjust.method = "BH") 
} else { 
  NULL 
}

print(pairwise_wilcoxon_result)


#RNA expression
counts_rna_expression = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/bulk_metaT_RNA_vOTU/5893_genes_expression_vOTUs.csv", header = T, sep=",") #geaParse non-template strand

jaccard_rna_expression = counts_rna_expression %>%
  select(-length, -gene_id) %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0))) %>%
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

#write.csv(jaccard_rna_expression, file="jaccard_RNA_expression.csv")

#Alright - now let's decipher some ecology.

```

``` {r Virus-Host Links}
#Let's do DNA

variables_to_keep5 = c("datastream_metadat", "relabund_dna_abund_genome", "geTMM_dna_expression_genome", "relabund_rna_abundance_genome", "jaccard_rna_expression", "sample_metadata") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep5)) #clean out the environment

dnahosts = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/virus-host-relationships/iphop_v2/parsed_Host_prediction_to_genome_m90_duplicates_fix.csv", header = TRUE, sep=",")

#Group by 'Host phylum' and 'source' and count viruses
grouped = dnahosts %>%
  group_by(`Host.phylum`, source) %>%
  summarise(count = n()) %>%
  ungroup()

# Step 3: Normalize the counts to get proportions
proportions = grouped %>%
  group_by(`Host.phylum`) %>%
  mutate(proportion = count / sum(count))

source_colors = c("DNA Virome" = "#73c5f6", "DNA EukFloat" = "#f0704a", "DNA Bacterial" = "#54bc00")

# Step 4: Create the stacked bar chart with reversed order on y-axis
dna_hosts = ggplot(proportions, aes(x = proportion, y = fct_rev(`Host.phylum`), fill = source)) + 
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = source_colors) +
  labs(
    title = 'Proportion of Viruses per Source for each Host Phylum',
    x = 'Proportion of all viruses',
    y = 'Host Phylum'
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  guides(fill=guide_legend(title="Source"))

dna_hosts
#ggsave(dna_hosts, file = "stacked_barchart_DNA.pdf")

#Now lets do RNA
rnahosts = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/figures/rna_virus_hosts/rna_virus_hosts.csv", header = TRUE, sep=",")

# Remove rows where keep_remove is "remove"
filtered_df = rnahosts[rnahosts$keep_remove != "remove", ]

grouped_rna = filtered_df %>%
  group_by(pred.L1, sample_origin) %>%
  summarise(count = n()) %>%
  ungroup()

#Normalize the counts to get proportions
proportions_rna = grouped_rna %>%
  group_by(pred.L1) %>%
  mutate(proportion = count / sum(count))

# Define the colors (adjust to your RNA sources)
rna_source_colors = c("RNA Virome" = "#c5b4c5", "RNA PolyA" = "#8ba494", "RNA Bulk" = "#fedd8d")

# Step 4: Create the stacked bar chart with reversed order on y-axis
rna_host_predictions = ggplot(proportions_rna, aes(x = proportion, y = fct_rev(pred.L1), fill = sample_origin)) + 
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = rna_source_colors) +
  labs(
    title = 'Proportion of Viruses per Sample Origin for each Pred.L1',
    x = 'Proportion of all viruses',
    y = 'Pred.L1'
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  guides(fill=guide_legend(title="Sample Origin"))

rna_host_predictions
#ggsave(plot = rna_host_predictions, "rna_host_predictions_proportions_v2.pdf", height = 6, width = 6)

#Ok i really like these, but now i also want to show the total proportion per each data stream overall of each.

#DNA first
# Step 2: Group by 'Host phylum' and 'source' and count viruses
grouped = dnahosts %>%
  group_by(`Host.phylum`, source) %>%
  summarise(count = n()) %>%
  ungroup()

# Step 3: Normalize the counts to get proportions
proportions = grouped %>%
  group_by(source) %>%
  mutate(proportion = count / sum(count))

# Define the colors
host_phylum_colors = c(
  "#000000", "#ffb6c1", "#8b4513", "#08acd5", "#808000",
  "#483d8b", "#3cb371", "#000080", "#8b008b", "#8bd5ee", "#b03060",
  "#ff0000", "#ffd700", "#00ff00", "#9400d3", "#00ff7f",
  "#dc143c", "#00ffff", "#0000ff", "#ff7f50",
  "#f0e68c", "#6495ed", "#ff1493", "#7b68ee", "#f5f5dc",
  "#ee82ee", "#87cefa", "#006400"
)
# Create a named vector for colors
host_phylum_levels = unique(dnahosts$`Host.phylum`)
names(host_phylum_colors) = host_phylum_levels

# Step 4: Create the stacked bar chart
dnaprops = ggplot(proportions, aes(x = source, y = proportion, fill = `Host.phylum`)) + 
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = host_phylum_colors) +
  labs(
    title = 'Proportion of Host Phylum per Source',
    x = 'Source',
    y = 'Proportion of all viruses'
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5)
  ) +
  guides(fill=guide_legend(title="Host Phylum"))

dnaprops

#ggsave(dnaprops, file="DNA_props_barsSOM.pdf")
# Lets do this for RNA.
# Calculate total counts per sample_origin
total_counts = aggregate(counts ~ sample_origin, data = filtered_df, sum)
colnames(total_counts) = c("sample_origin", "total_counts")

# Merge total_counts back to filtered_df
merged_df = merge(filtered_df, total_counts, by = "sample_origin")

# Calculate proportion
merged_df$proportion = merged_df$counts / merged_df$total_counts

# Create the stacked bar chart
rna_host_predictions = ggplot(data = merged_df, aes(x = sample_origin, y = proportion, fill = pred.L1)) +
  geom_bar(stat = "identity") +
  labs(title = "Proportion of Counts by Predicted Host within Each Sample Origin",
       x = "Sample Origin", y = "Proportion", fill = "Predicted Host") +
  theme_minimal()
rna_host_predictions

```

```{r Alpha-diversity across seasons)}

#For the richness metrics, going to use the DNA and RNA vOTU abundances

#Write in the metadata for the samples. 
sample_metadata = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/supplementary_tables/TableSX_sample_metadata.csv")

#Let's pivot long the abundances for dna and rna and merge them with metadata. 
relabund_dna_abund_genome_long = relabund_dna_abund_genome %>%
  rownames_to_column(var="genome_id") %>% #move this in
  pivot_longer(-genome_id, 
               values_to = "abund",
               names_to = "sample") %>% #pivot longer
  left_join(sample_metadata, by = "sample")

relabund_rna_abundance_genome_long = relabund_rna_abundance_genome %>%
    rownames_to_column(var="genome_id") %>% #move this in
  pivot_longer(-genome_id, 
               values_to = "abund",
               names_to = "sample") %>% #pivot longer
  left_join(sample_metadata, by = "sample")

#
#
#
## Start with DNA vOTUs
#
#
#

#Now let's get richness values for season
richness_DNA_season = relabund_dna_abund_genome_long %>%
  group_by(sample, Season) %>%
  summarise(Richness = sum(abund > 0))

#Perform ANOVA
anova_result_season = aov(Richness ~ Season, data = richness_DNA_season)
summary(anova_result_season)
TukeyHSD(anova_result_season) #No significance here. Expected.
  
mcolors_richness_season=c("#ffbf5e", "#68873b")

# Plot richness
DNA_richness_season_consolidated = ggplot(richness_DNA_season, aes(x = Season, y = Richness, fill = Season)) +
  geom_boxplot() +
  labs(title = "DNA vOTU richness per season", x = "Season", y = "Richness") +
  theme_minimal() +
  scale_fill_manual(values=mcolors_richness_season) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

DNA_richness_season_consolidated

#
#
#
## Now with RNA vOTUs
#
#
#
#Now let's get richness values for season
richness_RNA_season = relabund_rna_abundance_genome_long %>%
  group_by(sample, Season) %>%
  summarise(Richness = sum(abund > 0))

#Perform ANOVA
anova_rna_result_season = aov(Richness ~ Season, data = richness_RNA_season)
summary(anova_rna_result_season)
TukeyHSD(anova_rna_result_season) #No significance here. Expected.
  
mcolors_richness_season=c("#ffbf5e", "#68873b")

# Plot richness
RNA_richness_season_consolidated = ggplot(richness_RNA_season, aes(x = Season, y = Richness, fill = Season)) +
  geom_boxplot() +
  labs(title = "RNA vOTU richness per season", x = "Season", y = "Richness") +
  theme_minimal() +
  scale_fill_manual(values=mcolors_richness_season) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

RNA_richness_season_consolidated

#variables_to_keep6 = c("datastream_metadat", "sample_metadata", "relabund_dna_abund_genome", "geTMM_dna_expression_genome", "relabund_rna_abundance_genome", "jaccard_rna_expression") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
#rm(list=setdiff(ls(), variables_to_keep6)) #clean out the environment

```

```{r viral beta diversity- abundance and expression patterns via NMDS}

#Now lets look at some NMDS. Loading in the NMR data that we have to overlay.

nmr_chem = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/supplementary_tables/env_chemistry_NMR_noGal.csv", header = T)

biogeochem = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/supplementary_tables/env_biogeochemistry.csv", header=T, row.names = 1) 

biogeochem_df = biogeochem %>%
  t() %>%
  as.data.frame()

nmr_chem_df = nmr_chem %>%
  select(-c(2:8)) %>% #remove the extra stuff.
  column_to_rownames("compound") %>%
  t() %>%
  as.data.frame()
  
#
#
#
#DNA vOTUs
#
#
#

#Abundance

# PERMANOVA
dm.vOTUs_dna_abund=calc_dm(relabund_dna_abund_genome, method = "bray")
adonis2(formula = dm.vOTUs_dna_abund ~ Irrigation, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ Plot, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ Season, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ percent_water_content, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ percent_water_content * Plot, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ percent_water_content * Plot - percent_water_content:Plot, data = sample_metadata, permutations = 999)

#Let's do some NMDS
Ord_full_dna_abund=metaMDS(t(relabund_dna_abund_genome), distance = "bray", noshare = T, trace = 1, autotransform=T) #make distance matrix
stressplot(Ord_full_dna_abund) #ew.

#I think that the virome data mapping may be too sparse for this. Let's see if i remove the SM1001 outlier that only has a handful of vOTUs.
relabund_dna_abund_genome_noSM1001SM1002 = relabund_dna_abund_genome %>%
  select(-SM1001, -SM1002)

#Let's do some NMDS

#Lets subset the metadata too.
sample_metadata_noSM1001SM1002 = sample_metadata %>%
  filter(!grepl("SM1001|SM1002", sample))
  
# PERMANOVA
dm.vOTUs_dna_abund=calc_dm(relabund_dna_abund_genome_noSM1001SM1002, method = "bray")
adonis2(formula = dm.vOTUs_dna_abund ~ Irrigation, data = sample_metadata_noSM1001SM1002, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ Plot, data = sample_metadata_noSM1001SM1002, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ Season, data = sample_metadata_noSM1001SM1002, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ percent_water_content, data = sample_metadata_noSM1001SM1002, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ percent_water_content * Plot, data = sample_metadata_noSM1001SM1002, permutations = 999)
adonis2(formula = dm.vOTUs_dna_abund ~ percent_water_content * Plot - percent_water_content:Plot, data = sample_metadata_noSM1001SM1002, permutations = 999)


Ord_full_dna_abund=metaMDS(t(relabund_dna_abund_genome_noSM1001SM1002), distance = "bray", noshare = T, trace = 1, autotransform=T) #make distance matrix
stressplot(Ord_full_dna_abund) #eh. better i guess. but data very sparse.

Ord_full_dna_abund.scores = as.data.frame(vegan::scores(Ord_full_dna_abund)$sites)
Ord_full_dna_abund.scores$irrigationtreatment = sample_metadata_noSM1001SM1002$Irrigation
Ord_full_dna_abund.scores$plot = sample_metadata_noSM1001SM1002$Plot
Ord_full_dna_abund.scores$plot=as.factor(Ord_full_dna_abund.scores$plot)
Ord_full_dna_abund.scores$datesampled = sample_metadata_noSM1001SM1002$Season
Ord_full_dna_abund.scores$percent_water_content = sample_metadata_noSM1001SM1002$percent_water_content
Ord_full_dna_abund.scores$water_category_soft = sample_metadata_noSM1001SM1002$water_category_soft

mcolors=c("#628b29", "#ffcdbd", "#e66294","#2F9DA1", "#FF5F5F", "#c5c5c5", "#83deff", "#eeffc5",  "#39394a", "#eeca03", "#de9400","#ffeea4")

shape_values = c("T1" = 15,  # Square
                  "T4" = 16)  # Circle

shape_values = c("fall" = 15,  # Square
                  "spring" = 16)  # Circle

irrigation_treatment_and_plot_DNA_abundance = Ord_full_dna_abund.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=plot), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color()+
  theme_bw()  +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU NMDS Abundance Irrigation Treatment")

irrigation_treatment_and_plot_DNA_abundance

irrigation_treatment_and_water_DNA_abundance = Ord_full_dna_abund.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=water_category_soft), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color() +
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  theme_bw()  +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU DNA Abundance NMDS Moisture Content")

irrigation_treatment_and_water_DNA_abundance

#Ok, now let's plot this with the NMR data.

####Simple Ord with env factors

#Subset to exclude SM1001 and SM1002
nmr_chem_df_noSM1001SM1002 = nmr_chem_df %>%
  rownames_to_column(var="sample") %>%
  filter(!grepl("SM1001|SM1002", sample)) %>%
  column_to_rownames("sample")

biogeochem_df_noSM1001SM1002 = biogeochem_df %>%
  rownames_to_column(var="sample") %>%
  filter(!grepl("SM1001|SM1002", sample)) %>%
  column_to_rownames("sample")

#start with prcomp
chemDNAabund.pca=prcomp(na.omit(biogeochem_df_noSM1001SM1002), center=TRUE, scale.=TRUE)
DNAabundord=metaMDS(t(relabund_dna_abund_genome_noSM1001SM1002), distance = "bray")
chemDNAabundfit_ord = envfit(DNAabundord, biogeochem_df_noSM1001SM1002, perm = 999, na.rm=TRUE)
vegan::scores(chemDNAabundfit_ord, "vectors")
#pdf("chemical_plot.pdf")
plot(DNAabundord)
plot(chemDNAabundfit_ord)
plot(chemDNAabundfit_ord, p.max = 0.05, col = "green")
#dev.off()

#This establishes the coordinates for the samples and all vOTUS onto an non-metric dimensional scaling
ord_chemDNAabund=metaMDS(t(relabund_dna_abund_genome_noSM1001SM1002))
ord_chemDNAabund # the stress for this should be around <.1 
stressplot(ord_chemDNAabund) #scatter seems close to the line, demonstrating that it is a good fit. All good!

#envfit here will fit the vectors onto the ordination established above
fit_ord_chemDNAabund = envfit(ord_chemDNAabund, biogeochem_df_noSM1001SM1002, perm = 999, na.rm=TRUE)
vegan::scores(fit_ord_chemDNAabund, "vectors")

#Now to start actually plotting this on ggplot.
NMDS_Bray_DNAabund =metaMDS(t(relabund_dna_abund_genome_noSM1001SM1002), distance = "bray", k =2,
                              noshare = 0.1, trace = 1, trymax = 999, autotransform=T)
stressplot(NMDS_Bray_DNAabund) #looks good
 
DNAabund_data.scores = as.data.frame(vegan::scores(NMDS_Bray_DNAabund)$sites)
DNAabund_data.scores$irrigationtreatment = sample_metadata_noSM1001SM1002$Irrigation
DNAabund_data.scores$plot = sample_metadata_noSM1001SM1002$Plot
DNAabund_data.scores$plot=as.factor(DNAabund_data.scores$plot)
DNAabund_data.scores$datesampled = sample_metadata_noSM1001SM1002$Season
DNAabund_data.scores$percent_water_content = sample_metadata_noSM1001SM1002$percent_water_content
DNAabund_data.scores$water_category_soft = sample_metadata_noSM1001SM1002$water_category_soft

en_DNAabund = envfit(NMDS_Bray_DNAabund, biogeochem_df_noSM1001SM1002, permutations = 999, na.rm = TRUE)
en_coord_cont_DNAabund = as.data.frame(vegan::scores(en_DNAabund, "vectors")) * ordiArrowMul(en_DNAabund)
en_coord_cont_DNAabund$Compound = rownames(en_coord_cont_DNAabund)

###########Now do the final plot with the loadings as bars.
distance = function(x, y, home = c(0,0)) {
  sqrt((x-home[1])^2 + (y-home[2])^2)
}

#create loadings df for plot arrows
v_scrs = as.data.frame(vegan::scores(en_DNAabund, display = "vectors"))
v_scrs = cbind(v_scrs*ordiArrowMul(en_DNAabund), Compound = rownames(v_scrs))

v_scrs = v_scrs %>%
  mutate(dist_pc1pc2 = distance(NMDS1, NMDS2), #distance in space from center
         scaled_dist = dist_pc1pc2 * 10)

#get top 10 compounds based on distance in space from center
top_dist_compounds = v_scrs %>%
  arrange(desc(scaled_dist)) %>%
  slice_head(n = 10) %>%
  mutate(num_lab = 1:10) %>%
  select(Compound, num_lab)

#make plotting columns for loadings df
v_scrs = v_scrs %>%
  mutate(top_c = ifelse(Compound %in% top_dist_compounds$Compound,"top","other"),
         alpha_factor = ifelse(top_c == "top", 1, 0.5),
         plot_pc1 = ifelse(top_c == "top", NMDS1, 0),
         plot_pc2 = ifelse(top_c == "top", NMDS2, 0),
         top_label = ifelse(top_c == "top", Compound, "")) %>%
  left_join(top_dist_compounds, by = c("Compound"))

DNAabund_samplePoint_bars = DNAabund_data.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_segment(data = v_scrs,
               aes(x= 0, xend = NMDS1*1, 
                   y = 0, yend = NMDS2*1, 
                   alpha = alpha_factor,
                   color = Compound),
               arrow = arrow(length = unit(0.5, "cm")),
               inherit.aes = FALSE)  +
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  scale_color_manual(values=wes_palette("FantasticFox1", type="continuous", 50)) + 
  geom_text(data = v_scrs,
            aes(label = num_lab,
                x = NMDS1*1,
                y = NMDS2*1),
            size = 3) +
  new_scale_color()+
  geom_point(aes(fill = water_category_soft), size = 4, shape = 21) +
  theme_bw()

DNAabund_samplePoint_bars

#ggsave(DNAabund_samplePoint_bars, file="DNA_abund_NMDS_wLoadings_biogeo_v3.pdf", height=8, width=13)

#
#Expression for DNA vOTUs now.
#


# PERMANOVA
dm.vOTUs_dna_express=calc_dm(geTMM_dna_expression_genome, method = "bray")
adonis2(formula = dm.vOTUs_dna_express ~ Irrigation, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_express ~ Plot, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_express ~ Season, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_express ~ percent_water_content, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_express ~ percent_water_content * Plot, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_dna_express ~ percent_water_content * Plot - percent_water_content:Plot, data = sample_metadata, permutations = 999)










#Let's do some NMDS
Ord_full_dna_express=metaMDS(t(geTMM_dna_expression_genome), distance = "bray", noshare = T, trace = 1, autotransform=T) #make distance matrix
stressplot(Ord_full_dna_express) #good enuff.
Ord_full_dna_express.scores = as.data.frame(vegan::scores(Ord_full_dna_express)$sites)
Ord_full_dna_express.scores$irrigationtreatment = sample_metadata$Irrigation
Ord_full_dna_express.scores$plot = sample_metadata$Plot
Ord_full_dna_express.scores$plot=as.factor(Ord_full_dna_express.scores$plot)
Ord_full_dna_express.scores$datesampled = sample_metadata$Season
Ord_full_dna_express.scores$percent_water_content = sample_metadata$percent_water_content
Ord_full_dna_express.scores$water_category_soft = sample_metadata$water_category_soft

mcolors=c("#628b29", "#ffcdbd", "#e66294","#2F9DA1", "#FF5F5F", "#c5c5c5", "#83deff", "#eeffc5",  "#39394a", "#eeca03", "#de9400","#ffeea4")

shape_values = c("T1" = 15,  # Square
                  "T4" = 16)  # Circle

shape_values = c("fall" = 15,  # Square
                  "spring" = 16)  # Circle

irrigation_treatment_and_plot_DNA_expression = Ord_full_dna_express.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=plot), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color()+
  theme_bw()  +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU NMDS expression Irrigation Treatment")

irrigation_treatment_and_plot_DNA_expression

irrigation_treatment_and_water_DNA_expression = Ord_full_dna_express.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=water_category_soft), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color()+
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  theme_bw()  +
  geom_text(aes(label = plot), vjust = 1.5, hjust = 1, size = 3) +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU DNA expression NMDS Moisture Content")

irrigation_treatment_and_water_DNA_expression


#Ok, now let's plot this with the NMR data.

####Simple Ord with env factors
#start with prcomp
chemdnaexpress.pca=prcomp(na.omit(biogeochem_df_noSM1001SM1002), center=TRUE, scale.=TRUE)
dnaexpressord=metaMDS(t(geTMM_dna_expression_genome), distance = "bray")
chemdnaexpressfit_ord = envfit(dnaexpressord, biogeochem_df, perm = 999, na.rm=TRUE)
vegan::scores(chemdnaexpressfit_ord, "vectors")
#pdf("chemical_plot_dnaexpress.pdf")
plot(dnaexpressord)
plot(chemdnaexpressfit_ord)
plot(chemdnaexpressfit_ord, p.max = 0.05, col = "green")
#dev.off()

#This establishes the coordinates for the samples and all vOTUS onto an non-metric dimensional scaling
ord_chemdnaexpress=metaMDS(t(geTMM_dna_expression_genome))
ord_chemdnaexpress # the stress for this should be around <.1 
stressplot(ord_chemdnaexpress) #scatter seems close to the line, demonstrating that it is a good fit. All good!

#envfit here will fit the vectors onto the ordination established above
fit_ord_chemdnaexpress = envfit(ord_chemdnaexpress, biogeochem_df, perm = 999, na.rm=TRUE)
vegan::scores(fit_ord_chemdnaexpress, "vectors")

#Now to start actually plotting this on ggplot.
NMDS_Bray_dnaexpress =metaMDS(t(geTMM_dna_expression_genome), distance = "bray", k =2,
                              noshare = 0.1, trace = 1, trymax = 999, autotransform=T)
stressplot(NMDS_Bray_dnaexpress) #looks good
 
dnaexpress_data.scores = as.data.frame(vegan::scores(NMDS_Bray_dnaexpress)$sites)
dnaexpress_data.scores$irrigationtreatment = sample_metadata$Irrigation
dnaexpress_data.scores$plot = sample_metadata$Plot
dnaexpress_data.scores$plot=as.factor(dnaexpress_data.scores$plot)
dnaexpress_data.scores$datesampled = sample_metadata$Season
dnaexpress_data.scores$percent_water_content = sample_metadata$percent_water_content
dnaexpress_data.scores$water_category_soft = sample_metadata$water_category_soft

en_dnaexpress = envfit(NMDS_Bray_dnaexpress, biogeochem_df, permutations = 999, na.rm = TRUE)
en_coord_cont_dnaexpress = as.data.frame(vegan::scores(en_dnaexpress, "vectors")) * ordiArrowMul(en_dnaexpress)
en_coord_cont_dnaexpress$Compound = rownames(en_coord_cont_dnaexpress)

###########Now do the final plot with the loadings as bars.
distance = function(x, y, home = c(0,0)) {
  sqrt((x-home[1])^2 + (y-home[2])^2)
}

#create loadings df for plot arrows
v_scrs = as.data.frame(vegan::scores(en_dnaexpress, display = "vectors"))
v_scrs = cbind(v_scrs*ordiArrowMul(en_dnaexpress), Compound = rownames(v_scrs))

v_scrs = v_scrs %>%
  mutate(dist_pc1pc2 = distance(NMDS1, NMDS2), #distance in space from center
         scaled_dist = dist_pc1pc2 * 10)

#get top 10 compounds based on distance in space from center
top_dist_compounds = v_scrs %>%
  arrange(desc(scaled_dist)) %>%
  slice_head(n = 10) %>%
  mutate(num_lab = 1:10) %>%
  select(Compound, num_lab)

#make plotting columns for loadings df
v_scrs = v_scrs %>%
  mutate(top_c = ifelse(Compound %in% top_dist_compounds$Compound,"top","other"),
         alpha_factor = ifelse(top_c == "top", 1, 0.5),
         plot_pc1 = ifelse(top_c == "top", NMDS1, 0),
         plot_pc2 = ifelse(top_c == "top", NMDS2, 0),
         top_label = ifelse(top_c == "top", Compound, "")) %>%
  left_join(top_dist_compounds, by = c("Compound"))

dnaexpress_samplePoint_bars = dnaexpress_data.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_segment(data = v_scrs,
               aes(x= 0, xend = NMDS1*1, 
                   y = 0, yend = NMDS2*1, 
                   alpha = alpha_factor,
                   color = Compound),
               arrow = arrow(length = unit(0.5, "cm")),
               inherit.aes = FALSE)  +
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  scale_color_manual(values=wes_palette("FantasticFox1", type="continuous", 50)) + 
  geom_text(data = v_scrs,
            aes(label = num_lab,
                x = NMDS1*1,
                y = NMDS2*1),
            size = 3) +
  new_scale_color()+
  geom_point(aes(fill = water_category_soft), size = 4, shape = 21) +
  theme_bw()

dnaexpress_samplePoint_bars

#ggsave(dnaexpress_samplePoint_bars, file="DNA_express_wLoadings.pdf", height=8, width=13)

#
#
#
#RNA vOTUs
#
#
#

#Abundance

# PERMANOVA
dm.vOTUs_RNA_abund=calc_dm(relabund_rna_abundance_genome, method = "bray")
adonis2(formula = dm.vOTUs_RNA_abund ~ Irrigation, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_RNA_abund ~ Plot, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_RNA_abund ~ Season, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_RNA_abund ~ percent_water_content, data = sample_metadata, permutations = 999)

#Let's do some NMDS
Ord_full_RNA_abund=metaMDS(t(relabund_rna_abundance_genome), distance = "bray", noshare = T, trace = 1, autotransform=T) #make distance matrix
stressplot(Ord_full_RNA_abund) #good enuff.
Ord_full_RNA_abund.scores = as.data.frame(vegan::scores(Ord_full_RNA_abund)$sites)
Ord_full_RNA_abund.scores$irrigationtreatment = sample_metadata$Irrigation
Ord_full_RNA_abund.scores$plot = sample_metadata$Plot
Ord_full_RNA_abund.scores$plot=as.factor(Ord_full_RNA_abund.scores$plot)
Ord_full_RNA_abund.scores$datesampled = sample_metadata$Season
Ord_full_RNA_abund.scores$percent_water_content = sample_metadata$percent_water_content
Ord_full_RNA_abund.scores$water_category_soft = sample_metadata$water_category_soft

mcolors=c("#628b29", "#ffcdbd", "#e66294","#2F9DA1", "#FF5F5F", "#c5c5c5", "#83deff", "#eeffc5",  "#39394a", "#eeca03", "#de9400","#ffeea4")

shape_values = c("T1" = 15,  # Square
                  "T4" = 16)  # Circle

shape_values = c("fall" = 15,  # Square
                  "spring" = 16)  # Circle

irrigation_treatment_and_plot_RNA_abundance = Ord_full_RNA_abund.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=plot), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color()+
  theme_bw()  +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU NMDS Abundance Irrigation Treatment")

irrigation_treatment_and_plot_RNA_abundance

irrigation_treatment_and_water_RNA_abundance = Ord_full_RNA_abund.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=water_category_soft), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color()+
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  theme_bw()  +
  geom_text(aes(label = plot), vjust = 1.5, hjust = 1, size = 3) +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU RNA Abundance NMDS Moisture Content")

irrigation_treatment_and_water_RNA_abundance

#Ok, now let's plot this with the NMR data.

####Simple Ord with env factors
#start with prcomp
chemrnaabund.pca=prcomp(na.omit(biogeochem_df_noSM1001SM1002), center=TRUE, scale.=TRUE)
rnaabundord=metaMDS(t(relabund_rna_abundance_genome), distance = "bray")
chemrnaabundfit_ord = envfit(rnaabundord, biogeochem_df, perm = 999, na.rm=TRUE)
vegan::scores(chemrnaabundfit_ord, "vectors")
#pdf("chemical_plot_RNAabund.pdf")
plot(rnaabundord)
plot(chemrnaabundfit_ord)
plot(chemrnaabundfit_ord, p.max = 0.05, col = "green")
#dev.off()

#This establishes the coordinates for the samples and all vOTUS onto an non-metric dimensional scaling
ord_chemrnaabund=metaMDS(t(relabund_rna_abundance_genome))
ord_chemrnaabund # the stress for this should be around <.1 
stressplot(ord_chemrnaabund) #scatter seems close to the line, demonstrating that it is a good fit. All good!

#envfit here will fit the vectors onto the ordination established above
fit_ord_chemrnaabund = envfit(ord_chemrnaabund, biogeochem_df, perm = 999, na.rm=TRUE)
vegan::scores(fit_ord_chemrnaabund, "vectors")

#Now to start actually plotting this on ggplot.
NMDS_Bray_rnaabund =metaMDS(t(relabund_rna_abundance_genome), distance = "bray", k =2,
                              noshare = 0.1, trace = 1, trymax = 999, autotransform=T)
stressplot(NMDS_Bray_rnaabund) #looks good
 
rnaabund_data.scores = as.data.frame(vegan::scores(NMDS_Bray_rnaabund)$sites)
rnaabund_data.scores$irrigationtreatment = sample_metadata$Irrigation
rnaabund_data.scores$plot = sample_metadata$Plot
rnaabund_data.scores$plot=as.factor(rnaabund_data.scores$plot)
rnaabund_data.scores$datesampled = sample_metadata$Season
rnaabund_data.scores$percent_water_content = sample_metadata$percent_water_content
rnaabund_data.scores$water_category_soft = sample_metadata$water_category_soft

en_rnaabund = envfit(NMDS_Bray_rnaabund, biogeochem_df, permutations = 999, na.rm = TRUE)
en_coord_cont_rnaabund = as.data.frame(vegan::scores(en_rnaabund, "vectors")) * ordiArrowMul(en_rnaabund)
en_coord_cont_rnaabund$Compound = rownames(en_coord_cont_rnaabund)

###########Now do the final plot with the loadings as bars.
distance = function(x, y, home = c(0,0)) {
  sqrt((x-home[1])^2 + (y-home[2])^2)
}

#create loadings df for plot arrows
v_scrs = as.data.frame(vegan::scores(en_rnaabund, display = "vectors"))
v_scrs = cbind(v_scrs*ordiArrowMul(en_rnaabund), Compound = rownames(v_scrs))

v_scrs = v_scrs %>%
  mutate(dist_pc1pc2 = distance(NMDS1, NMDS2), #distance in space from center
         scaled_dist = dist_pc1pc2 * 10)

#get top 10 compounds based on distance in space from center
top_dist_compounds = v_scrs %>%
  arrange(desc(scaled_dist)) %>%
  slice_head(n = 10) %>%
  mutate(num_lab = 1:10) %>%
  select(Compound, num_lab)

#make plotting columns for loadings df
v_scrs = v_scrs %>%
  mutate(top_c = ifelse(Compound %in% top_dist_compounds$Compound,"top","other"),
         alpha_factor = ifelse(top_c == "top", 1, 0.5),
         plot_pc1 = ifelse(top_c == "top", NMDS1, 0),
         plot_pc2 = ifelse(top_c == "top", NMDS2, 0),
         top_label = ifelse(top_c == "top", Compound, "")) %>%
  left_join(top_dist_compounds, by = c("Compound"))

rnaabund_samplePoint_bars = rnaabund_data.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_segment(data = v_scrs,
               aes(x= 0, xend = NMDS1*1, 
                   y = 0, yend = NMDS2*1, 
                   alpha = alpha_factor,
                   color = Compound),
               arrow = arrow(length = unit(0.5, "cm")),
               inherit.aes = FALSE)  +
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  scale_color_manual(values=wes_palette("FantasticFox1", type="continuous", 50)) + 
  geom_text(data = v_scrs,
            aes(label = num_lab,
                x = NMDS1*1,
                y = NMDS2*1),
            size = 3) +
  new_scale_color()+
  geom_point(aes(fill = water_category_soft), size = 4, shape = 21) +
  theme_bw()

rnaabund_samplePoint_bars

#ggsave(rnaabund_samplePoint_bars, file="rna_abund_NMDS_wLoadings_v2.pdf", height=8, width=13)

#
#Expression
#

# PERMANOVA
dm.vOTUs_RNA_express=calc_dm(jaccard_rna_expression, method = "bray")

#Oh ok theres a sample in here (SM1029) that got no recruitment. Going to remove from the metadat and the expression.

jaccard_rna_expression_noSM1029 = jaccard_rna_expression %>%
  select(-SM1029)

sample_metadata_noSM1029 = sample_metadata %>%
  filter(sample != "SM1029")

#Ok so this runs...  
dm.vOTUs_RNA_express=calc_dm(jaccard_rna_expression_noSM1029, method = "bray")

#Let's do some NMDS
Ord_full_RNA_express=metaMDS(dm.vOTUs_RNA_express, distance = "jaccard", noshare = T, trace = 1, autotransform=T) 

#eeeh. It ran on the calc_dm buit metaMDS is still giving a bad ordination as denoted by the stressplot.

#Bummer. This is just not really going to work. The expressed matrix is too sparse to make a solid ordination. Going to try this a little differently, i'm now going to filter out the vOTUs that had abundances to those that had any mapping into the expressed strand. I.e., i'm going to use the abundance values as proxies for any vOTU that had mapping to nontemplate.

#make this a df to left join
relabund_rna_abundance_genome_df = relabund_rna_abundance_genome %>%
  rownames_to_column("genome_id")

#left join.
RNA_expressed_abundProxy = jaccard_rna_expression %>%
  rownames_to_column(var="genome_id") %>%
  select(c(genome_id)) %>%
  left_join(relabund_rna_abundance_genome_df, by="genome_id") %>%
  column_to_rownames(var="genome_id")

#write.csv(RNA_expressed_abundProxy, file="RNA_expressed_abundProxy.csv")

Ord_full_RNA_express_proxy=metaMDS(t(RNA_expressed_abundProxy), distance = "bray", noshare = T, trace = 1, autotransform=T) 

# PERMANOVA
dm.vOTUs_RNA_expProx=calc_dm(RNA_expressed_abundProxy, method = "bray")
adonis2(formula = dm.vOTUs_RNA_expProx ~ Irrigation, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_RNA_expProx ~ Plot, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_RNA_expProx ~ Season, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_RNA_expProx ~ percent_water_content, data = sample_metadata, permutations = 999)

#make distance matrix
stressplot(Ord_full_RNA_express_proxy) #not too shabby. Proceeding.
Ord_full_RNA_express_proxy.scores = as.data.frame(vegan::scores(Ord_full_RNA_express_proxy)$sites)
Ord_full_RNA_express_proxy.scores$irrigationtreatment = sample_metadata$Irrigation
Ord_full_RNA_express_proxy.scores$plot = sample_metadata$Plot
Ord_full_RNA_express_proxy.scores$plot=as.factor(Ord_full_RNA_express_proxy.scores$plot)
Ord_full_RNA_express_proxy.scores$datesampled = sample_metadata$Season
Ord_full_RNA_express_proxy.scores$percent_water_content = sample_metadata$percent_water_content
Ord_full_RNA_express_proxy.scores$water_category_soft = sample_metadata$water_category_soft

mcolors=c("#628b29", "#ffcdbd", "#e66294","#2F9DA1", "#FF5F5F", "#c5c5c5", "#83deff", "#eeffc5",  "#39394a", "#eeca03", "#de9400","#ffeea4")

shape_values = c("T1" = 15,  # Square
                  "T4" = 16)  # Circle

shape_values = c("fall" = 15,  # Square
                  "spring" = 16)  # Circle

irrigation_treatment_and_plot_RNA_expression_proxy = Ord_full_RNA_express_proxy.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=plot), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color()+
  theme_bw()  +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU NMDS expression Irrigation Treatment")

irrigation_treatment_and_plot_RNA_expression_proxy

irrigation_treatment_and_water_RNA_expression_proxy = Ord_full_RNA_express_proxy.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=water_category_soft), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color()+
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  theme_bw()  +
  geom_text(aes(label = plot), vjust = 1.5, hjust = 1, size = 3) +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU RNA expression proxy NMDS Moisture Content")

irrigation_treatment_and_water_RNA_expression_proxy

combined_NMDS_plots = ggarrange(irrigation_treatment_and_water_DNA_abundance, irrigation_treatment_and_water_DNA_expression, irrigation_treatment_and_water_RNA_abundance, irrigation_treatment_and_water_RNA_expression_proxy)

#ggsave(combined_NMDS_plots, width=15, height=12, file="combined_nmds_plots.pdf")

#Ok, now let's plot this with the NMR data.

####Simple Ord with env factors
#start with prcomp
chemrnaexpress.pca=prcomp(na.omit(biogeochem_df), center=TRUE, scale.=TRUE)
rnaexpressord=metaMDS(t(RNA_expressed_abundProxy), distance = "bray")
chemrnaexpressfit_ord = envfit(rnaexpressord, biogeochem_df, perm = 999, na.rm=TRUE)
vegan::scores(chemrnaexpressfit_ord, "vectors")
#pdf("chemical_plot_rnaexpress.pdf")
plot(rnaexpressord)
plot(chemrnaexpressfit_ord)
plot(chemrnaexpressfit_ord, p.max = 0.05, col = "green")
#dev.off()

#This establishes the coordinates for the samples and all vOTUS onto an non-metric dimensional scaling
ord_chemrnaexpress=metaMDS(t(RNA_expressed_abundProxy))
ord_chemrnaexpress # the stress for this should be around <.1 
stressplot(ord_chemrnaexpress) #scatter seems close to the line, demonstrating that it is a good fit. All good!

#envfit here will fit the vectors onto the ordination established above
fit_ord_chemrnaexpress = envfit(ord_chemrnaexpress, biogeochem_df, perm = 999, na.rm=TRUE)
vegan::scores(fit_ord_chemrnaexpress, "vectors")

#Now to start actually plotting this on ggplot.
NMDS_Bray_rnaexpress =metaMDS(t(RNA_expressed_abundProxy), distance = "bray", k =2,
                              noshare = 0.1, trace = 1, trymax = 999, autotransform=T)
stressplot(NMDS_Bray_rnaexpress) #looks good
 
rnaexpress_data.scores = as.data.frame(vegan::scores(NMDS_Bray_rnaexpress)$sites)
rnaexpress_data.scores$irrigationtreatment = sample_metadata$Irrigation
rnaexpress_data.scores$plot = sample_metadata$Plot
rnaexpress_data.scores$plot=as.factor(rnaexpress_data.scores$plot)
rnaexpress_data.scores$datesampled = sample_metadata$Season
rnaexpress_data.scores$percent_water_content = sample_metadata$percent_water_content
rnaexpress_data.scores$water_category_soft = sample_metadata$water_category_soft

en_rnaexpress = envfit(NMDS_Bray_rnaexpress, biogeochem_df, permutations = 999, na.rm = TRUE)
en_coord_cont_rnaexpress = as.data.frame(vegan::scores(en_rnaexpress, "vectors")) * ordiArrowMul(en_rnaexpress)
en_coord_cont_rnaexpress$Compound = rownames(en_coord_cont_rnaexpress)

###########Now do the final plot with the loadings as bars.
distance = function(x, y, home = c(0,0)) {
  sqrt((x-home[1])^2 + (y-home[2])^2)
}

#create loadings df for plot arrows
v_scrs = as.data.frame(vegan::scores(en_rnaexpress, display = "vectors"))
v_scrs = cbind(v_scrs*ordiArrowMul(en_rnaexpress), Compound = rownames(v_scrs))

v_scrs = v_scrs %>%
  mutate(dist_pc1pc2 = distance(NMDS1, NMDS2), #distance in space from center
         scaled_dist = dist_pc1pc2 * 10)

#get top 10 compounds based on distance in space from center
top_dist_compounds = v_scrs %>%
  arrange(desc(scaled_dist)) %>%
  slice_head(n = 10) %>%
  mutate(num_lab = 1:10) %>%
  select(Compound, num_lab)

#make plotting columns for loadings df
v_scrs = v_scrs %>%
  mutate(top_c = ifelse(Compound %in% top_dist_compounds$Compound,"top","other"),
         alpha_factor = ifelse(top_c == "top", 1, 0.5),
         plot_pc1 = ifelse(top_c == "top", NMDS1, 0),
         plot_pc2 = ifelse(top_c == "top", NMDS2, 0),
         top_label = ifelse(top_c == "top", Compound, "")) %>%
  left_join(top_dist_compounds, by = c("Compound"))

rnaexpress_samplePoint_bars = rnaexpress_data.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_segment(data = v_scrs,
               aes(x= 0, xend = NMDS1*0.5, 
                   y = 0, yend = NMDS2*0.5, 
                   alpha = alpha_factor,
                   color = Compound),
               arrow = arrow(length = unit(0.5, "cm")),
               inherit.aes = FALSE)  +
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  scale_color_manual(values=wes_palette("FantasticFox1", type="continuous", 50)) + 
  geom_text(data = v_scrs,
            aes(label = num_lab,
                x = NMDS1*0.5,
                y = NMDS2*0.5),
            size = 3) +
  new_scale_color()+
  geom_point(aes(fill = water_category_soft), size = 4, shape = 21) +
  theme_bw()

rnaexpress_samplePoint_bars

#ggsave(rnaexpress_samplePoint_bars, file="rna_express_wLoadings_v2.pdf", height=8, width=13)

#Now lets look at the lysogeny vs lytic distributions along the moisture gradients

lysogeny_vOTUs = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/viral_lifestyle/lysogenic_DNA_vOTU_expression_geTMM.csv", header = T)

lysogeny_vOTUs_long = lysogeny_vOTUs %>%
  pivot_longer( cols = -X, 
    names_to = "sample", 
    values_to = "expression") %>%
  left_join(sample_metadata, by = "sample")

ggplot(lysogeny_vOTUs_long, aes(x = percent_water_content, y = log(expression), color = water_category_soft)) +
  geom_point() +
  labs(title = "Boxplot of Expression Values by Moisture Condition",
       x = "Moisture Condition (water_category_soft)",
       y = "Expression") +
  theme_minimal()

#Not looking too hot. lets just make sure here:

ggplot(lysogeny_vOTUs_long, aes(x = water_category_soft, y = log(expression))) +
  geom_boxplot() +
  labs(title = "Lysogeny Expression across Moisture Categories",
       x = "Moisture Category",
       y = "Expression") +
  theme_minimal()

lysogeny_vOTUs_df = lysogeny_vOTUs %>%
  column_to_rownames(var="X")

# PERMANOVA
dm.vOTUs_lysogenic=calc_dm(lysogeny_vOTUs_df, method = "bray")
adonis2(formula = dm.vOTUs_lysogenic ~ Plot, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_lysogenic ~ Season, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_lysogenic ~ percent_water_content, data = sample_metadata, permutations = 999)

#nothing here significant.

#Let's try this one more time but using rpk instead of geTMM, let's see if that final normalization step is causing weird distribution issues because these are overall low abundance.

lysogeny_vOTUs_RPK = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/viral_lifestyle/lysogenic_DNA_vOTU_expression_rpk.csv", header = T)

lysogeny_vOTUs_RPK_long = lysogeny_vOTUs_RPK %>%
  pivot_longer( cols = -X, 
    names_to = "sample", 
    values_to = "expression") %>%
  left_join(sample_metadata, by = "sample")

lysogeny_vOTUs_RPK_filtered = lysogeny_vOTUs_RPK_long %>% 
  filter(expression != 0)

ggplot(lysogeny_vOTUs_RPK_filtered, aes(x = percent_water_content, y = log(expression), color = water_category_soft)) +
  geom_point() +
  labs(title = "Boxplot of Expression Values by Moisture Condition",
       x = "Moisture Condition (water_category_soft)",
       y = "Expression") +
  theme_minimal()

#Not looking too hot. lets just make sure here:

ggplot(lysogeny_vOTUs_RPK_filtered, aes(x = water_category_soft, y = expression)) +
  geom_bar(stat = "identity") +
  labs(title = "Lysogeny Expression across Moisture Categories",
       x = "Moisture Category",
       y = "Log(Expression)") +
  theme_minimal()

#Pattern much more clear here. Let's see some stats.

kruskal_test = kruskal.test(expression ~ water_category_soft, data = lysogeny_vOTUs_RPK_filtered)
print(kruskal_test)

#There it is. now for wilcoxon:
pairwise_wilcoxon_result = NULL
if (kruskal_test$p.value < 0.05) {
  pairwise_wilcoxon_result = pairwise.wilcox.test(
    lysogeny_vOTUs_RPK_filtered$expression, 
    lysogeny_vOTUs_RPK_filtered$water_category_soft, 
    p.adjust.method = "BH"  # Benjamini-Hochberg method for p-value adjustment
  )
}

print(pairwise_wilcoxon_result)

ggplot(lysogeny_vOTUs_RPK_long, aes(x = Season, y = log(expression))) +
  geom_boxplot() +
  labs(title = "Lysogeny Expression across Season Categories",
       x = "Moisture Category",
       y = "Expression") +
  theme_minimal()

lysogeny_vOTUs_RPK_df = lysogeny_vOTUs_RPK %>%
  column_to_rownames(var="X")

# PERMANOVA
dm.vOTUs_lysogenic=calc_dm(lysogeny_vOTUs_RPK_df, method = "bray")
adonis2(formula = dm.vOTUs_lysogenic ~ Plot, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_lysogenic ~ Season, data = sample_metadata, permutations = 999)
adonis2(formula = dm.vOTUs_lysogenic ~ percent_water_content, data = sample_metadata, permutations = 999)

#Nope



#Let's make one final plot here that looks at the total number of vOTUs that were active from the DNA and RNA groups across moistures.

geTMM_dna_vOTUs_count = geTMM_dna_expression_genome %>%
  summarise(across(everything(), ~ sum(. > 0))) %>%
  gather(Sample, Detected_vOTUs_DNA)

# Calculate number of detected vOTUs in each sample for RNA
Ord_full_RNA_vOTUs_count = RNA_expressed_abundProxy %>%
  summarise(across(everything(), ~ sum(. > 0))) %>%
  gather(Sample, Detected_vOTUs_RNA)

sample_moisture = data.frame(
  sample = c("SM1001", "SM1002", "SM1027", "SM1028", "SM1029", "SM1003", "SM1026", "SM1030", "SM1050", "SM1000", "SM1004", "SM1005", "SM1031"),
  moisture = c(rep("Low", 5), rep("Intermediate", 4), rep("High", 4))
)

# Ensure column names match for merging
colnames(sample_moisture) = c("Sample", "Moisture")

# Merge the moisture levels information with DNA and RNA vOTUs count data
geTMM_dna_vOTUs_count = geTMM_dna_vOTUs_count %>%
  left_join(sample_moisture, by = "Sample")

Ord_full_RNA_vOTUs_count = Ord_full_RNA_vOTUs_count %>%
  left_join(sample_moisture, by = "Sample")


DNA_active_counts = ggplot(geTMM_dna_vOTUs_count, aes(x = Moisture, y = Detected_vOTUs_DNA, fill = Moisture)) +
  geom_boxplot() +
  geom_jitter() +
  labs(title = "Distribution of Total Active DNA vOTUs Across Moisture Levels",
       x = "Moisture Level",
       y = "Total DNA vOTUs") +
  theme_minimal() +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934"))

# Boxplot for RNA
RNA_active_counts = ggplot(Ord_full_RNA_vOTUs_count, aes(x = Moisture, y = Detected_vOTUs_RNA, fill = Moisture)) +
  geom_boxplot() +
  geom_jitter() +
  labs(title = "Distribution of Total Active RNA vOTUs Across Moisture Levels",
       x = "Moisture Level",
       y = "Total RNA vOTUs") +
  theme_minimal() +
  scale_fill_manual(values = c("Low" = "#d46d93", "Intermediate" = "#f5cfbe", "High" = "#698934"))

DNA_active_counts
RNA_active_counts

#ggsave(DNA_active_counts, file="active_DNA_counts.pdf")
#ggsave(RNA_active_counts, file="active_RNA_counts.pdf")

kw_dna = kruskal.test(Detected_vOTUs_DNA ~ Moisture, data = geTMM_dna_vOTUs_count)
print(kw_dna)

wilcox_dna = pairwise.wilcox.test(geTMM_dna_vOTUs_count$Detected_vOTUs_DNA, 
                                   geTMM_dna_vOTUs_count$Moisture, 
                                   p.adjust.method = "BH")
print(wilcox_dna)

kw_rna = kruskal.test(Detected_vOTUs_RNA ~ Moisture, data = Ord_full_RNA_vOTUs_count)
print(kw_rna)

wilcox_rna = pairwise.wilcox.test(Ord_full_RNA_vOTUs_count$Detected_vOTUs_RNA, 
                                   Ord_full_RNA_vOTUs_count$Moisture, 
                                   p.adjust.method = "BH")
print(wilcox_rna)

```

```{r Bacterial and Archaeal community patterns}

variables_to_keep7 = c("datastream_metadat", "sample_metadata", "nmr_chem_df", "NMDS_Bray_dnaexpress", "geTMM_dna_expression_genome", "RNA_expressed_abundProxy", "biogeochem_df") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep7)) #clean out the environment

#I generated these MAGs from the bacterial metagenomes. now i'm giong to try and do some ordinations with them.

MAG_expression = read.table("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/featureCounts_376_MAGs_output_unstranded_overlapping_paired.txt", sep="\t", header = T)

MAG_expression_noZero =  MAG_expression %>% 
  filter(rowSums(select(., 7:19)) != 0) %>% #Remove rows where the sum of the values in columns 7 to 19 is zero - just to make the processing quicker.
  mutate(across(7:19, ~ ifelse(. < 5, 0, .))) %>% #Replace counts less than 5 with zero. Minimum of 5 counts per gene.
  filter(rowSums(select(., 7:19)) != 0) %>% #Re-filter out any gene that is completely zero
  mutate(full_id = paste(Chr, Geneid, sep = "_")) %>% # Append Geneid column to Chr column with an underscore separator
  column_to_rownames("full_id") %>%
  select(-Geneid, -Chr, -Start, -End, -Strand) #Remove a few cols.
  
#calculate RPK
rpk_metaT_MAGs = ((MAG_expression_noZero[,2:14]*10^3)/MAG_expression_noZero[,1]) #note, we multiply by 10^3 here because geTMM expects kilobase pairs on lengths and featurecounts_dna_expression reports bps.
group_metaT_MAGs = c(rep("A",ncol(rpk_metaT_MAGs)))

#calculate geTMM
rpk.norm_MAGs = DGEList(counts=rpk_metaT_MAGs,group=group_metaT_MAGs)
rpk.norm_MAGs = calcNormFactors(rpk.norm_MAGs)
geTMM_MAGs_norm.expression.rpk_edger = as.data.frame(cpm(rpk.norm_MAGs))

#Let's add these up for myself by sample moisture. 
geTMM_MAGs_norm.expression.rpk_edger$low_moisture_sum = rowSums(geTMM_MAGs_norm.expression.rpk_edger[, c("SM1001", "SM1002", "SM1027", "SM1028", "SM1029")])

# Create the "intermediate_moisture_sum" column
geTMM_MAGs_norm.expression.rpk_edger$intermediate_moisture_sum = rowSums(geTMM_MAGs_norm.expression.rpk_edger[, c("SM1003", "SM1026", "SM1030", "SM1050")])

# Create the "high_moisture_sum" column
geTMM_MAGs_norm.expression.rpk_edger$high_moisture_sum = rowSums(geTMM_MAGs_norm.expression.rpk_edger[, c("SM1000", "SM1004", "SM1005", "SM1031")])

#write.csv(geTMM_MAGs_norm.expression.rpk_edger, file="MAG_geTMM_expression.csv")

#now aggregate these at a genome level. Bring back the ids from the original file
geTMM_MAGs_expression_genome = geTMM_MAGs_norm.expression.rpk_edger %>%
  rownames_to_column("full_id") %>%
  mutate(bin_id = str_extract(full_id, "^SM\\d+_bin\\.\\d+")) %>% #pull out bin info
  select(-full_id) %>% #remove the full id were gonna aggregate
  group_by(bin_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #aggregate
  ungroup() %>%
  column_to_rownames("bin_id") #clean.

# Sum the expression values for each sample column
sample_sums = colSums(rpk_metaT_MAGs)

# Create a data frame from the summed values
sample_sums_df = data.frame(Sample = names(sample_sums), 
                             TotalExpression = sample_sums)

# Define the moisture levels for each sample
sample_sums_df = sample_sums_df %>%
  mutate(Moisture = case_when(
    Sample %in% c("SM1001", "SM1002", "SM1027", "SM1028", "SM1029") ~ "Low",
    Sample %in% c("SM1003", "SM1026", "SM1030", "SM1050") ~ "Intermediate",
    Sample %in% c("SM1000", "SM1004", "SM1005", "SM1031") ~ "High",
    TRUE ~ NA_character_
  ))

# Remove any NA values in Moisture (if there are any samples not categorized)
sample_sums_df = sample_sums_df %>% filter(!is.na(Moisture))

# Create the boxplot with specified colors
rpk_MAG_moisture = ggplot(sample_sums_df, aes(x = Moisture, y = TotalExpression, fill = Moisture)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.5) +
  scale_fill_manual(values = c("Low" = "#e66294", "Intermediate" = "#ffcdbd", "High" = "#628b29")) +
  labs(title = "Boxplot of Total Gene Expression by Moisture Level",
       x = "Moisture Level",
       y = "Total Sum of Gene Expression") +
  theme_minimal()

rpk_MAG_moisture

#ggsave(rpk_MAG_moisture, file="MAG_rpk_expression.pdf")

# Perform ANOVA to test for significant differences
anova_result = aov(TotalExpression ~ Moisture, data = sample_sums_df)
summary(anova_result)

# Perform Tukey's HSD test for pairwise comparisons
tukey_result = TukeyHSD(anova_result)
print(tukey_result)

#Just for ease of access i'm going to bring in the annotations for all of these expressed genes.
MAG_annotations = read.delim("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/supplementary_tables/MAG_annotations.tsv", sep="\t", header = T)

geTMM_MAGs_expression_genome = geTMM_MAGs_expression_genome %>%
  select(-c(low_moisture_sum, intermediate_moisture_sum, high_moisture_sum)) #Remove these sums that i made for the plot above.

#Now to start actually plotting community expression on ggplot.
NMDS_Bray_MAG=metaMDS(t(geTMM_MAGs_expression_genome), distance = "bray", k =2,
                              noshare = 0.1, trace = 1, trymax = 999, autotransform=T)
stressplot(NMDS_Bray_MAG) #looks good

#start with prcomp
chemmagexpress.pca=prcomp(na.omit(biogeochem_df), center=TRUE, scale.=TRUE)
magaexpressord=metaMDS(t(geTMM_MAGs_expression_genome), distance = "bray")
chemmagexpressfit_ord = envfit(magaexpressord, biogeochem_df, perm = 999, na.rm=TRUE)
vegan::scores(chemmagexpressfit_ord, "vectors")
#pdf("chemical_plot_MAGexpress.pdf")
plot(magaexpressord)
plot(chemmagexpressfit_ord)
plot(chemmagexpressfit_ord, p.max = 0.05, col = "green")
#dev.off()


MAG_data.scores = as.data.frame(vegan::scores(NMDS_Bray_MAG)$sites)
MAG_data.scores$irrigationtreatment = sample_metadata$Irrigation
MAG_data.scores$plot = sample_metadata$Plot
MAG_data.scores$plot=as.factor(MAG_data.scores$plot)
MAG_data.scores$datesampled = sample_metadata$Season
MAG_data.scores$percent_water_content = sample_metadata$percent_water_content
MAG_data.scores$water_category_soft = sample_metadata$water_category_soft

#Quick one here:
mcolors=c("#628b29", "#ffcdbd", "#e66294","#2F9DA1", "#FF5F5F", "#c5c5c5", "#83deff", "#eeffc5",  "#39394a", "#eeca03", "#de9400","#ffeea4")

shape_values = c("fall" = 15,  # Square
                  "spring" = 16)  # Circle

MAG_simplePlot = MAG_data.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(shape=datesampled, color=plot), size = 5) +
  scale_color_manual(values=mcolors) +
  new_scale_color()+
  theme_bw()  +
  scale_color_manual(values=mcolors) +
  scale_fill_manual(values=mcolors) +
  scale_shape_manual(values=shape_values) +
  labs(title="vOTU NMDS expression Irrigation Treatment")

MAG_simplePlot

#Now more detailed


en_MAG = envfit(NMDS_Bray_MAG, biogeochem_df, permutations = 999, na.rm = TRUE)
en_coord_cont_MAG = as.data.frame(vegan::scores(en_MAG, "vectors")) * ordiArrowMul(en_MAG)
en_coord_cont_MAG$Compound = rownames(en_coord_cont_MAG)

###########Now do the final plot with the loadings as bars.
distance = function(x, y, home = c(0,0)) {
  sqrt((x-home[1])^2 + (y-home[2])^2)
}

#create loadings df for plot arrows
v_scrs = as.data.frame(vegan::scores(en_MAG, display = "vectors"))
v_scrs = cbind(v_scrs*ordiArrowMul(en_MAG), Compound = rownames(v_scrs))

v_scrs = v_scrs %>%
  mutate(dist_pc1pc2 = distance(NMDS1, NMDS2), #distance in space from center
         scaled_dist = dist_pc1pc2 * 10)

#get top 10 compounds based on distance in space from center
top_dist_compounds = v_scrs %>%
  arrange(desc(scaled_dist)) %>%
  slice_head(n = 10) %>%
  mutate(num_lab = 1:10) %>%
  select(Compound, num_lab)

#make plotting columns for loadings df
v_scrs = v_scrs %>%
  mutate(top_c = ifelse(Compound %in% top_dist_compounds$Compound,"top","other"),
         alpha_factor = ifelse(top_c == "top", 1, 0.5),
         plot_pc1 = ifelse(top_c == "top", NMDS1, 0),
         plot_pc2 = ifelse(top_c == "top", NMDS2, 0),
         top_label = ifelse(top_c == "top", Compound, "")) %>%
  left_join(top_dist_compounds, by = c("Compound"))

MAG_samplePoint_bars = MAG_data.scores %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_segment(data = v_scrs,
               aes(x= 0, xend = NMDS1*1, 
                   y = 0, yend = NMDS2*1, 
                   alpha = alpha_factor,
                   color = Compound),
               arrow = arrow(length = unit(0.5, "cm")),
               inherit.aes = FALSE)  +
  geom_polygon(aes(fill = water_category_soft, color = water_category_soft), alpha = 0.2, linetype=2, position = "identity", rule="winding") +
  scale_color_manual(values=wes_palette("FantasticFox1", type="continuous", 50)) + 
  geom_text(data = v_scrs,
            aes(label = num_lab,
                x = NMDS1*1,
                y = NMDS2*1),
            size = 3) +
  new_scale_color()+
  geom_point(aes(fill = water_category_soft), size = 4, shape = 21) +
  theme_bw()

MAG_samplePoint_bars

#ggsave(MAG_samplePoint_bars, file="MAG_expr_NMDS_wLoadings.pdf", height=8, width=13)

#Dang this looks almost identical to the DNA vOTU NMDS. Lets see if significantly similar:

proc_dna_vs_mag=procrustes(NMDS_Bray_dnaexpress, NMDS_Bray_MAG, scale=TRUE, symmetric=T)## S3 method for class 'procrustes':
proc_dna_vs_mag
summary(proc_dna_vs_mag)## S3 method for class 'procrustes':

# Open a PDF device
#pdf("procrustes_plot_kind1.pdf")
# Create the first plot
plot(proc_dna_vs_mag, kind=1, type='text')
# Close the PDF device
#dev.off()

# Open another PDF device for the second plot
#pdf("procrustes_plot_kind2.pdf")
# Create the second plot
plot(proc_dna_vs_mag, kind=2, type='text')
# Close the PDF device
#dev.off()

residuals(proc_dna_vs_mag)

protest(NMDS_Bray_dnaexpress, NMDS_Bray_MAG, scores = 'sites', symmetric=T, permutations=999)

#Yep there it is. Cool.

```


```{r Understanding occupancy and splitting}

variables_to_keep8 = c("datastream_metadat", "sample_metadata", "nmr_chem_df", "geTMM_dna_expression_genome", "RNA_expressed_abundProxy", "biogeochem_df") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep8)) #clean out the environment

occupancy_expresss = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/preliminary_analyses/geTMM_normalized_metaT_3.4_DNA_vOTUs_grouped_v2.csv")

occupancy_expresss_filtered = occupancy_expresss %>%
  filter(!(lower_avg == 0 & higher_avg == 0))

scatter_plot = ggplot(occupancy_expresss_filtered, aes(x = lower_avg, y = higher_avg, size = occupancy, color = class)) +
  geom_point(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  scale_y_log10() +
  labs(title = "Scatterplot of Higher_avg vs Lower_avg",
       x = "Low Moisture Average geTMM (log scale)",
       y = "High Moisture Average geTMM (log scale)",
       size = "Occupancy",
       color = "Class")

scatter_plot

# Density plot above the scatterplot
density_plot_x = ggplot(occupancy_expresss_filtered, aes(x = lower_avg, fill = class)) +
  geom_density(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  labs(title = "Density Plot of Lower_avg by Class",
       x = "Low Moisture Average geTMM (log scale)") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

density_plot_x

# Density plot to the right of the scatterplot
density_plot_y = ggplot(occupancy_expresss_filtered, aes(x = higher_avg, fill = class)) +
  geom_density(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  labs(title = "Density Plot of Higher_avg by Class",
       x = "High Moisture Average geTMM (log scale)") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  coord_flip()  # Flip coordinates for density on y-axis

density_plot_y

#ggsave(scatter_plot, file = "scatterplot_Express.pdf", width = 8, height = 5)
#ggsave(density_plot_x, file = "density_x_Express.pdf")
#ggsave(density_plot_y, file = "density_y_Express.pdf")

###
#Let's take a step back here. I want to make a similar plot but with expression on x and with abundance on y. I will then make two plots, one for low moisture, one for high moisture. i will only do this for organisms that are expressed, and remove anything that is abundance but not expressed. This plot is going to give us information regarding viruses that are expressed and whether they are also highly abundant.

#I'm going to read in the files from the normalization steps that i did initially. 

DNA_vOTU_expression = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/geTMM_normalized_DNA_vOTU_expression.csv")

DNA_vOTU_abundance = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/relabund_DNA_vOTU_abundance.csv")

DNA_vOTU_abundance_and_expression = merge(DNA_vOTU_expression, DNA_vOTU_abundance, by = "X")

sample_metadata = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/supplementary_tables/TableSX_sample_metadata.csv")

vOTU_abund_expression_df_wide = DNA_vOTU_abundance_and_expression %>%
  pivot_longer(
    cols = -X, 
    names_to = "sample_var", 
    values_to = "value"
    ) %>%
  separate(sample_var, into = c("sample_id", "data_type"), sep = "_", extra = "merge") %>%
  pivot_wider(names_from = data_type, values_from = value)

# Merge with sample_metadata
merged_with_metadata = vOTU_abund_expression_df_wide %>%
  left_join(sample_metadata, by = c("sample_id" = "sample")) %>%
  select(-c(5, 9:11, 13:15, 17:26))

#write.csv(merged_with_metadata, file = "mered_with_metadata.csv")

#One more merge, have to bring in the occupancy calls.

occupancy = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/occupancy.csv")

DNA_vOTU_abundance_and_expression_w_occupancy = merge(merged_with_metadata, occupancy, by = "X")

#write.csv(DNA_vOTU_abundance_and_expression_w_occupancy, file = "dna_abund_occupancy.csv")

df_filtered = DNA_vOTU_abundance_and_expression_w_occupancy %>% 
  filter(MT > 0, MG > 0) #just leaving this here to test it. 

ggplot(DNA_vOTU_abundance_and_expression_w_occupancy, aes(x = occupancy, y = log(MT), fill = occupancy)) +
  geom_violin(trim = FALSE) +
  geom_boxplot(width = 0.1, position = position_dodge(width = 0.9), alpha = 0.5, colour = "black") +
  theme_minimal() +
  labs(title = "MT Distribution Across Occupancy Groups", x = "Occupancy Group", y = "MT") +
  theme(legend.position = "none")

ggplot(DNA_vOTU_abundance_and_expression_w_occupancy, aes(x = occupancy, y = log(MG), fill = occupancy)) +
  geom_violin(trim = FALSE) +
  geom_boxplot(width = 0.1, position = position_dodge(width = 0.9), alpha = 0.5, colour = "black") +
  theme_minimal() +
  labs(title = "MG Distribution Across Occupancy Groups", x = "Occupancy Group", y = "MG") +
  theme(legend.position = "none")

#These violin plots and scatter plots really suggest that occupancy doesn't totally matter. lets make sure now by making an NMDS of these vOTUs.

DNA_vOTU_abundance_and_expression_MT = DNA_vOTU_abundance_and_expression %>%
  select(1:14)

DNA_vOTU_abundance_and_expression_MG = DNA_vOTU_abundance_and_expression %>%
  select(1, 15:27)# %>%
  #select(-c(SM1001_MG, SM1002_MG))

merged_df_w_occupancy = merge(DNA_vOTU_abundance_and_expression_MT, occupancy, by="X")

merged_w_occupancy_long_df = merged_df_w_occupancy %>%
  pivot_longer(cols = 2:(ncol(merged_df_w_occupancy)-1), names_to = "sample", values_to = "expression")

#Theres so much zeroes here that i'm wondering if i should remove them and only really compare what is present. problem is that idk if the zeroes are real, i am almost certain they are not. so then do we compare what we have? if yes - occupancy isn't totally relevant. If no - then obviously it looks like occupancy are highly different.

ggplot(merged_w_occupancy_long_df, aes(x = occupancy, y = log(expression), fill = occupancy)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Viral Expression by Occupancy", x = "Occupancy", y = "Expression")

ggplot(merged_w_occupancy_long_df, aes(x = occupancy, y = expression, fill = occupancy)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Viral Expression by Occupancy", x = "Occupancy", y = "Expression")

#I'm going to proceed here with the intermediate + high occupancy. The logic is that a virus needs to be in at least 25% of samples (4 sample minimum) to be considered for statistical analyses. There is enough logic here to not do stats and ecology on one-of abundances. so lets proceed with this subset for now.

merged_df_w_occupancy_int_high = merged_df_w_occupancy %>%
  filter(occupancy!="low") %>%
  column_to_rownames(var="X")


###
# Filter the data for higher moisture category and high/low occupancy
higher_moisture_df = DNA_vOTU_abundance_and_expression_w_occupancy %>% 
  filter(water_category_soft == 'higher', occupancy %in% c('high', 'low'))

# Perform t-test for MT expression between high and low occupancy in higher moisture category
t_test_higher_moisture = t.test(MT ~ occupancy, data = higher_moisture_df)

# Print the t-test result for higher moisture
print(paste("T-test result for higher moisture category:"))
print(t_test_higher_moisture)

# Filter the data for lower moisture category and high/low occupancy
lower_moisture_df = DNA_vOTU_abundance_and_expression_w_occupancy %>% 
  filter(water_category_soft == 'lower', occupancy %in% c('high', 'low'))

# Perform t-test for MT expression between high and low occupancy in lower moisture category
t_test_lower_moisture = t.test(MT ~ occupancy, data = lower_moisture_df)

# Print the t-test result for lower moisture
print(paste("T-test result for lower moisture category:"))
print(t_test_lower_moisture)

# Plot the data for higher moisture category
ggplot(data = higher_moisture_df, aes(x = occupancy, y = MT)) +
  geom_point() +
  labs(title = "Expression Levels in Higher Moisture by Occupancy", 
       x = "Occupancy", 
       y = "Expression Levels (MT)")

# Save the plot for higher moisture category
#ggsave("expression_levels_higher_moisture_occupancy.png")

# Plot the data for lower moisture category
ggplot(data = lower_moisture_df, aes(x = occupancy, y = MT)) +
  geom_point() +
  labs(title = "Expression Levels in Lower Moisture by Occupancy", 
       x = "Occupancy", 
       y = "Expression Levels (MT)")

# Save the plot for lower moisture category
#ggsave("expression_levels_lower_moisture_occupancy.png")

#Maybe we can test out some linear model here to account for sample-level variability?

library(lme4)
library(lmerTest)

lmer_model_all = lmer(MT ~ occupancy + water_category_soft + (1 | Plot), 
                       data = DNA_vOTU_abundance_and_expression_w_occupancy)

# Summarize the model
summary_model_all = summary(lmer_model_all)
print(paste("Linear Mixed-Effects Model summary:"))
print(summary_model_all)

#Now lets look at this a little differently. lets look at expression vs abundance on same plot.

scatter_plot = ggplot(DNA_vOTU_abundance_and_expression_w_occupancy, aes(x = MT, y = MG, size = occupancy, color = occupancy)) +
  geom_point(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  scale_y_log10() +
  labs(title = "Scatterplot of Higher_avg vs Lower_avg",
       x = "Expression (log)",
       y = "Abundance (log)",
       size = "Occupancy",
       color = "Class")

scatter_plot

# Density plot above the scatterplot
density_plot_x = ggplot(DNA_vOTU_abundance_and_expression_w_occupancy, aes(x = MT, fill = occupancy)) +
  geom_density(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  labs(title = "Density Plot of Lower_avg by Class",
       x = "Low Moisture Average geTMM (log scale)") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

density_plot_x

# Density plot to the right of the scatterplot
density_plot_y = ggplot(DNA_vOTU_abundance_and_expression_w_occupancy, aes(x = MG, fill = occupancy)) +
  geom_density(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  labs(title = "Density Plot of Higher_avg by Class",
       x = "High Moisture Average geTMM (log scale)") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  coord_flip()  # Flip coordinates for density on y-axis

density_plot_y


#ggsave(scatter_plot, file = "scatterplot_Express_vs_Abund.pdf", width = 8, height = 5)
#ggsave(density_plot_x, file = "density_x_Express_vs_Abund.pdf")
#ggsave(density_plot_y, file = "density_y_Express_vs_Abund.pdf")

#Now let's do this for the RNA expression to see those patterns:

RNA_occupancy_expresss = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/read_mapping_analyses/preliminary_analyses/rna_expression_prox.csv")

RNA_occupancy_express = RNA_occupancy_expresss %>%
  filter(!(lower_avg == 0 & higher_avg == 0))

scatter_plot = ggplot(RNA_occupancy_express, aes(x = lower_avg, y = higher_avg, size = occupancy, color = class)) +
  geom_point(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  scale_y_log10() +
  labs(title = "Scatterplot of Higher_avg vs Lower_avg",
       x = "Low Moisture Average geTMM (log scale)",
       y = "High Moisture Average geTMM (log scale)",
       size = "Occupancy",
       color = "Class")

scatter_plot

# Density plot above the scatterplot
density_plot_x = ggplot(RNA_occupancy_express, aes(x = lower_avg, fill = class)) +
  geom_density(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  labs(title = "Density Plot of Lower_avg by Class",
       x = "Low Moisture Average geTMM (log scale)") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

density_plot_x

# Density plot to the right of the scatterplot
density_plot_y = ggplot(RNA_occupancy_express, aes(x = higher_avg, fill = class)) +
  geom_density(alpha = 0.6) +  # Adjust alpha for opacity
  theme_minimal() +
  scale_x_log10() +
  labs(title = "Density Plot of Higher_avg by Class",
       x = "High Moisture Average geTMM (log scale)") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  coord_flip()  # Flip coordinates for density on y-axis

density_plot_y

#ggsave(scatter_plot, file = "scatterplot_Express_RNA.pdf", width = 8, height = 5)
#ggsave(density_plot_x, file = "density_x_Express_RNA.pdf")
#ggsave(density_plot_y, file = "density_y_Express_RNA.pdf"

variables_to_keep8 = c("datastream_metadat", "sample_metadata", "nmr_chem_df", "merged_df_w_occupancy_int_high", "geTMM_dna_expression_genome", "RNA_expressed_abundProxy", "RNA_occupancy_express") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep8)) #clean out the environment

```


```{r Viral correlations to geochemistry and metabolites}

RNA_vOTU_corr_df = RNA_expressed_abundProxy

biogeochem_df = read.csv("/Volumes/Macintosh HD/Users/rodr771/Library/CloudStorage/OneDrive-PNNL/Documents/3.4_interkingdom/supplementary_tables/env_biogeochemistry.csv", header = T)

biogeochem_df = biogeochem_df %>%
  column_to_rownames("Sample")

Ord_full_dna_express = metaMDS(t(geTMM_dna_expression_genome), distance = "bray", noshare = TRUE, trace = 1, autotransform = TRUE)
Ord_full_dna_scores = as.data.frame(vegan::scores(Ord_full_dna_express)$sites)

# NMDS for DNA viruses
Ord_full_dna_express = metaMDS(t(geTMM_dna_expression_genome), distance = "bray", noshare = TRUE, trace = 1, autotransform = TRUE)
Ord_full_dna_scores = as.data.frame(vegan::scores(Ord_full_dna_express)$sites)

# NMDS for RNA viruses
Ord_full_rna_express = metaMDS(t(RNA_vOTU_corr_df), distance = "bray", noshare = TRUE, trace = 1, autotransform = TRUE)
Ord_full_rna_scores = as.data.frame(vegan::scores(Ord_full_rna_express)$sites)

# Initialize an empty data frame to store correlation results
chem_features = rownames(biogeochem_df)
cor_results = data.frame(Feature = chem_features,
                         R_NMDS1_dna = numeric(length(chem_features)), p_value_NMDS1_dna = numeric(length(chem_features)),
                         R_NMDS2_dna = numeric(length(chem_features)), p_value_NMDS2_dna = numeric(length(chem_features)),
                         R_NMDS1_rna = numeric(length(chem_features)), p_value_NMDS1_rna = numeric(length(chem_features)),
                         R_NMDS2_rna = numeric(length(chem_features)), p_value_NMDS2_rna = numeric(length(chem_features)))

# Compute Spearman correlations and p-values for DNA
for (i in seq_along(chem_features)) {
  feature = chem_features[i]
  correlation_dna_NMDS1 = cor.test(Ord_full_dna_scores$NMDS1, t(biogeochem_df[feature, ]), method = "spearman", use = "pairwise.complete.obs")
  correlation_dna_NMDS2 = cor.test(Ord_full_dna_scores$NMDS2, t(biogeochem_df[feature, ]), method = "spearman", use = "pairwise.complete.obs")
  
  cor_results$R_NMDS1_dna[i] = correlation_dna_NMDS1$estimate
  cor_results$p_value_NMDS1_dna[i] = correlation_dna_NMDS1$p.value
  
  cor_results$R_NMDS2_dna[i] = correlation_dna_NMDS2$estimate
  cor_results$p_value_NMDS2_dna[i] = correlation_dna_NMDS2$p.value
}

# Compute Spearman correlations and p-values for RNA
for (i in seq_along(chem_features)) {
  feature = chem_features[i]
  correlation_rna_NMDS1 = cor.test(Ord_full_rna_scores$NMDS1, t(biogeochem_df[feature, ]), method = "spearman", use = "pairwise.complete.obs")
  correlation_rna_NMDS2 = cor.test(Ord_full_rna_scores$NMDS2, t(biogeochem_df[feature, ]), method = "spearman", use = "pairwise.complete.obs")
  
  cor_results$R_NMDS1_rna[i] = correlation_rna_NMDS1$estimate
  cor_results$p_value_NMDS1_rna[i] = correlation_rna_NMDS1$p.value
  
  cor_results$R_NMDS2_rna[i] = correlation_rna_NMDS2$estimate
  cor_results$p_value_NMDS2_rna[i] = correlation_rna_NMDS2$p.value
}

# Combine the results into a long-format data frame for plot
corrs_pivot_longer = cor_results %>%
  pivot_longer(
    cols = -Feature,
    names_to = c(".value", "NMDS_Axis", "Dataset"),
    names_pattern = "(.*)_NMDS(\\d)_(.*)")

# Create the scatter bubble plot
scatter_bubble = ggplot(corrs_pivot_longer, aes(x = Feature, y = R, size = p_value, color = Dataset, shape = NMDS_Axis)) +
  geom_point(alpha = 0.7) +
  theme_minimal() +
  labs(x = "Chemistry Feature", y = "Spearman Correlation (R)", size = "p-value", color = "Genome type", 
       shape = "NMDS Axis") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_y_continuous(breaks = seq(-1, 1, by = 0.5), limits = c(-1, 1)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.3)) +
  scale_color_manual(values = c("dna" = "#6daef8", "rna" = "#c4c100"))

scatter_bubble

#ggsave(scatter_bubble, file="scatter_bubble_NMSD1&2.pdf")

```

```{WGCNA - Unused for Manuscript}
library(WGCNA)

#I want to run WGCNA of the DNA viruses and their putative microbial hosts (MAGs). I want to make sure that i am accounting for normalizations, which means that i have to geTMM these datasets at the same time to get the distributions correct. Bringing in some of the code from the initial norms and merging them.

#Now we WGCNA

# Choosing the soft-thresholding power: analysis of network topology
allowWGCNAThreads() #this will enable multi threading.

#power = c(c(1:10), seq(from = 12, to=30, by=1)) # Choose a set of soft-thresholding powers
power = c(seq(1, 20, by = 1), seq(12, 20, by = 2))
                
sft = pickSoftThreshold(t(DNA_vOTU_expression_int_high), powerVector = power, verbose = 5, networkType = "signed hybrid") # Call the network topology analysis function

# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2))
cex1 = 0.9

# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=power,cex=cex1,col="red")
abline(h=0.60,col="red") # this line corresponds to using an R^2 cut-off of h

# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=power, cex=cex1,col="red")

power_thresh = 6 # Set power from first value to go over 0.8 in plot above.

DNA_vOTU_expression_int_high = DNA_vOTU_expression_int_high %>%
  column_to_rownames(var="genome_id")

# One-step network construction and module detection
set.seed(1234)
net = blockwiseModules(t(DNA_vOTU_expression_int_high), power = power_thresh,
                       TOMType = "signed", networkType = "signed hybrid",
                       minModuleSize = 20, ##
                       reassignThreshold = 0, mergeCutHeight = 0.25,
                       numericLabels = F, pamRespectsDendro = FALSE,
                       saveTOMs = F, 
                       verbose = 3)

# generating TOM matrix
TOM = TOMsimilarity(adjacency(t(DNA_vOTU_expression_int_high), power = power_thresh, type = "signed hybrid"), TOMType = "signed") # calculates TOM; the correlations used in
# creating networks in cytoscape

# exporting network for cytoscape
dimnames(TOM) = list(colnames(t(DNA_vOTU_expression_int_high), colnames(t(DNA_vOTU_expression_int_high)))) # name dimensions

cyt = exportNetworkToCytoscape(TOM,
                               edgeFile = paste0("Cyto_Edges_",
                                                 "0.1", "-thresh_", "signed",
                                                 ".txt"),
                               nodeFile = paste0("Cyto_Nodes_",
                                                 "0.1", "-thresh_", "signed",
                                                 ".txt"),
                               threshold = 0.1,
                               nodeAttr = labels2colors(net$colors))

# inspect modules
table(net$colors)
net$colors

# open a graphics window
sizeGrWindow(12, 9)

# Convert labels to colors for plotting if you selected numericLabels = T
#mergedColors = labels2colors(net$colors)
#table(mergedColors)

moduleColors = net$colors
moduleLabels = net$colors

# Plot the dendrogram and the module colors underneath
mergedColors = labels2colors(net$colors)

plotDendroAndColors(
  net$dendrograms[[1]],
  mergedColors[net$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )


MEs = net$MEs;
geneTree = net$dendrograms[[1]];
nPop = ncol(t(DNA_vOTU_expression_int_high))
nSamples = nrow(t(DNA_vOTU_expression_int_high))

#I like to write out the modules and the colors of each of the organisms. So im just rerunning the net command above to get them.
#write.csv(file="Module_eigen_values_allsamples_signedhybrid_picksft9.csv",MEs)
#write.csv(file="Module_composition_allsamples_signedhybrid_picksft9.csv",net$colors)

#I'm also going to create this merged file with the abundances so that I can use these modules for sPLS.
colorsModulesDf = as.data.frame(net$colors)
colorsModulesDf = tibble::rownames_to_column(colorsModulesDf, "genome_id")

filtered_vOTU_df_merge = DNA_vOTU_expression_int_high %>%
  rownames_to_column(var="genome_id")
filtered_vOTU_df_merge_MODULES = left_join(filtered_vOTU_df_merge, colorsModulesDf, by = "genome_id")
filtered_vOTU_df_merge_MODULES$modcol=filtered_vOTU_df_merge_MODULES$`net$colors`
filtered_vOTU_df_merge_MODULES= filtered_vOTU_df_merge_MODULES %>%
  filter(!is.na(modcol))

filtered_vOTU_df_merge_MODULES=filtered_vOTU_df_merge_MODULES %>%
  select(-c(`net$colors`))

#write.csv(file="WGCNA_modules.csv", filtered_vOTU_df_merge_MODULES)

# Calculate MEs with color labels
MEs0 = moduleEigengenes(t(DNA_vOTU_expression_int_high), moduleColors)$eigengenes
MEs = orderMEs(MEs0)

wgcna_metadata = nmr_chem_wMoisture_df

colnames(sample_metadata)[colnames(sample_metadata) == "sample"] = "Sample"

moduleTraitCor = cor(MEs, t(wgcna_metadata), use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
sapply(moduleTraitPvalue, class)

#Filter out and replace any p-value that is greater than 0.05 with a zero i can use to subset.
moduleTraitCor[moduleTraitCor > -0.5 & moduleTraitCor < 0.5] = 0
moduleTraitPvalue[moduleTraitPvalue > 0.05] = 0
textMatrix = paste(signif(moduleTraitCor, 2), " (",signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)

# Will display correlations and their p-values
sizeGrWindow(5,5)
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3))
par(mar = c(12, 5, 2, 2))

# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = rownames(wgcna_metadata),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))

# display with pheatmap
moduleTraitCor2 = as.matrix((moduleTraitCor))
#write.csv(file="TPM_normalized_module_to_trait_corrs_allsamples.csv",moduleTraitCor2)
moduleTraitCor2_t=t(moduleTraitCor2)
pheatmap_large = pheatmap(moduleTraitCor2_t, 
         cellwidth = 3,
         cellheight = 5,
         cluster_rows = F,
         cluster_cols = F,
         show_colnames = T,
         show_rownames = T,
         treeheight_col=T)

#ggsave(pheatmap_large, file="pheatmap_allsamples_picksft.pdf", width=20, height=5)
```