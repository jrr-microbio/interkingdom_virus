---
title: "3.4_interkingdom_commands"
author: "Josué Rodríguez-Ramos"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r load libs, ECHO=F}
library(indicspecies)
library(clusterProfiler)
library(gridExtra)
library(tidyr)
library(ggplot2)
library(edgeR)
library(stringr)
library(rstatix)
library(ggpubr)
library(wesanderson)
library(tibble)
library(mctoolsr)
library(ggnewscale)
library(dplyr)
library(reshape2)
library(tidyverse)
library(reticulate)
library(forcats)
library(patchwork)
library(DESeq2)
library(ashr)
library(ggrepel)
library(pls)
library(pheatmap)
library(UpSetR)
library(vegan)
library(cowplot)
library(broom)
library(lme4)
library(scales)

#library(per)
```


```{r Mapping stats, viral accumulation curves}

### Calculate species accumulation curve, richness and shannon's H (a helpful guide: https://kembellab.ca/r-workshop/biodivR/SK_Biodiversity_R.html , and https://rpubs.com/an-bui/vegan-cheat-sheet)

#Before going into richness and others, going to just really quickly plot out the read mapping statistics that i have.

# Read in the data
mapping_stats = read.delim("/methods_comparisons/read_mapping_statistics.csv", header = TRUE, sep=",")

# Reorder the factor levels
mapping_stats$Type = factor(mapping_stats$Type, levels = c("Vir_DNA", "Euk_DNA", "BAr_DNA", "Tot_DNA", "Vir_RNA", "Tot_RNA", "PolyA_RNA"))

# Create the plots
boxplot_readsused = ggplot(mapping_stats, aes(x = Type, y = ReadsUsed)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = Type), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Total reads") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("BAr_DNA" = "#54bc37", "Euk_DNA" = "#f0704a", "Vir_DNA" = "#73c5f6", "Tot_DNA" = "#ff7bac", "Tot_RNA" = "#fedd8d", "Vir_RNA" = "#c5b4c5", "PolyA_RNA" = "#8ba494")) +
  scale_color_manual(values = c("BAr_DNA" = "#54bc37", "Euk_DNA" = "#f0704a", "Vir_DNA" = "#73c5f6", "Tot_DNA" = "#ff7bac", "Tot_RNA" = "#fedd8d", "Vir_RNA" = "#c5b4c5", "PolyA_RNA" = "#8ba494")) + 
  theme(legend.position = "none")

boxplot_mapping = ggplot(mapping_stats, aes(x = Type, y = ReadsMapped)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = Type), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Total reads mapped") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("BAr_DNA" = "#54bc37", "Euk_DNA" = "#f0704a", "Vir_DNA" = "#73c5f6", "Tot_DNA" = "#ff7bac", "Tot_RNA" = "#fedd8d", "Vir_RNA" = "#c5b4c5", "PolyA_RNA" = "#8ba494")) +
  scale_color_manual(values = c("BAr_DNA" = "#54bc37", "Euk_DNA" = "#f0704a", "Vir_DNA" = "#73c5f6", "Tot_DNA" = "#ff7bac", "Tot_RNA" = "#fedd8d", "Vir_RNA" = "#c5b4c5", "PolyA_RNA" = "#8ba494")) + 
  theme(legend.position = "none")

boxplot_normalized = ggplot(mapping_stats, aes(x = Type, y = ReadsNormalized)) +
  geom_boxplot(aes(fill = Type)) +
  geom_jitter(aes(color = Type), position = position_jitter(width = 0.1), size = 2) +
  labs(x = "Sample Type", y = "Normalized counts (Reads mapped / Total reads)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  scale_fill_manual(values = c("BAr_DNA" = "#54bc37", "Euk_DNA" = "#f0704a", "Vir_DNA" = "#73c5f6", "Tot_DNA" = "#ff7bac", "Tot_RNA" = "#fedd8d", "Vir_RNA" = "#c5b4c5", "PolyA_RNA" = "#8ba494")) +
  scale_color_manual(values = c("BAr_DNA" = "#54bc37", "Euk_DNA" = "#f0704a", "Vir_DNA" = "#73c5f6", "Tot_DNA" = "#ff7bac", "Tot_RNA" = "#fedd8d", "Vir_RNA" = "#c5b4c5", "PolyA_RNA" = "#8ba494")) + 
  theme(legend.position = "none")

#ggsave(boxplot_normalized, file = "reads_Mapping_normalized.pdf", width = 7, height = 9)

# Arrange the plots
mappingstats_plots = grid.arrange(boxplot_readsused, boxplot_mapping, boxplot_normalized, ncol = 3)

#ggsave(mappingstats_plots, file="FigureX_MappingStats.pdf", height=6, width=14)

#For the richness, i made up some python code to take in the clusters output from the checkV and make a proper OTU-like table. I'm going to read that output OTU table now. This is better than just mapping either metaT or metaG because we have true counts data for each vOTU and whether it was or wasn't present in a sample!
mg_bacterial = read.delim("/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_DNA_bacteria_871.csv", header = T, sep=",", row.names = 1)

mg_eukfloat = read.delim("/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_DNA_EukFloat_3757.csv", header = T, sep=",", row.names = 1)

mg_virome = read.delim("/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_RNA_virome_3892.csv", header = T, sep=",", row.names = 1)

mg_total = read.delim("/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_DNA_total_1017.csv", header = T, sep=",", row.names = 1)

mt_bulk = read.delim("/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_RNA_bulkMetaT_4035.csv", header = T, sep=",", row.names = 1)

mt_virome = read.delim("/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_RNA_virome_3892.csv", header = T, sep=",", row.names = 1)

mt_polya = read.delim("/data_stream_comparisons/viral_accumulation_curves/otu_table_filtered_reordered_RNA_polyA_375.csv", header = T, sep=",", row.names = 1)

#Now I want to make accum curves for each of these individually, and then plot all of them in the same plot as well.

accumcurve_mg_bacterial = specaccum(t(mg_bacterial), method = "random", permutations=500)
accumcurve_mg_eukfloat = specaccum(t(mg_eukfloat), method = "random", permutations=500)
accumcurve_mg_virome = specaccum(t(mg_virome), method = "random", permutations=500)
accumcurve_mg_total = specaccum(t(mg_total), method = "random", permutations=500)
#
accumcurve_mt_bulk = specaccum(t(mt_bulk), method = "random", permutations=500)
accumcurve_mt_virome = specaccum(t(mt_virome), method = "random", permutations=500)
accumcurve_mt_polya = specaccum(t(mt_polya), method = "random", permutations=500)

# Function to compute slope
compute_slope = function(accum_curve) {
  fit = lm(accum_curve$richness ~ accum_curve$sites)
  slope = coef(fit)[2]
  return(slope)
}

# Calculate slopes
slope_mg_bacterial = compute_slope(accumcurve_mg_bacterial)
slope_mg_eukfloat = compute_slope(accumcurve_mg_eukfloat)
slope_mg_virome = compute_slope(accumcurve_mg_virome)
slope_mg_total = compute_slope(accumcurve_mg_total)
slope_mt_bulk = compute_slope(accumcurve_mt_bulk)
slope_mt_virome = compute_slope(accumcurve_mt_virome)
slope_mt_polya = compute_slope(accumcurve_mt_polya)

# Print the slopes
cat("Slope for mg_bacterial:", slope_mg_bacterial, "\n")
cat("Slope for mg_eukfloat:", slope_mg_eukfloat, "\n")
cat("Slope for mg_virome:", slope_mg_virome, "\n")
cat("Slope for mg_total:", slope_mg_total, "\n")
cat("Slope for mt_bulk:", slope_mt_bulk, "\n")
cat("Slope for mt_virome:", slope_mt_virome, "\n")
cat("Slope for mt_polya:", slope_mt_polya, "\n")

# Plot each species accumulation curve with slopes displayed
#pdf("viral_accumulation_curve_virome.pdf", width = 8, height = 6)
plot(accumcurve_mg_virome, add = FALSE, ci.type = "poly", col = "#73c5f6", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#73c5f6", 
     xlab = "Samples", ylab = "Number of viral populations")
text(max(accumcurve_mg_virome$sites), max(accumcurve_mg_virome$richness), labels = paste("Slope DNA virome:", round(slope_mg_virome, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the second plot as a PDF
#pdf("viral_accumulation_curve_eukfloat.pdf", width = 8, height = 6)
plot(accumcurve_mg_eukfloat, add = FALSE, ci.type = "poly", col = "#f0704a", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#f0704a")
text(max(accumcurve_mg_eukfloat$sites), max(accumcurve_mg_eukfloat$richness), labels = paste("Slope DNA EukFloat:", round(slope_mg_eukfloat, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the third plot as a PDF
#pdf("viral_accumulation_curve_bacterial.pdf", width = 8, height = 6)
plot(accumcurve_mg_bacterial, add = FALSE, ci.type = "poly", col = "#54bc37", lwd = 4, ci = 0.2, ci.lty = 1, ci.col = "#54bc37")
text(max(accumcurve_mg_bacterial$sites), max(accumcurve_mg_bacterial$richness), labels = paste("Slope DNA bacterial:", round(slope_mg_bacterial, 3)), adj = 1)
#dev.off()  # Close the PDF device

#pdf("viral_accumulation_curve_total.pdf", width = 8, height = 6)
plot(accumcurve_mg_total, add = FALSE, ci.type = "poly", col = "#ff7bac", lwd = 4, ci = 0.2, ci.lty = 1, ci.col = "#ff7bac")
text(max(accumcurve_mg_total$sites), max(accumcurve_mg_total$richness), labels = paste("Slope DNA bacterial:", round(slope_mg_total, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the fourth plot as a PDF
#pdf("viral_accumulation_curve_mt_bulk.pdf", width = 8, height = 6)
plot(accumcurve_mt_bulk, add = FALSE, ci.type = "poly", col = "#fedd8d", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#fedd8d")
text(max(accumcurve_mt_bulk$sites), max(accumcurve_mt_bulk$richness), labels = paste("Slope RNA bulk:", round(slope_mt_bulk, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the fifth plot as a PDF
#pdf("viral_accumulation_curve_mt_virome.pdf", width = 8, height = 6)
plot(accumcurve_mt_virome, add = FALSE, ci.type = "poly", col = "#c5b4c5", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#c5b4c5")
text(max(accumcurve_mt_virome$sites), max(accumcurve_mt_virome$richness), labels = paste("Slope RNA virome:", round(slope_mt_virome, 3)), adj = 1)
#dev.off()  # Close the PDF device

# Save the sixth plot as a PDF
#pdf("viral_accumulation_curve_mt_polya.pdf", width = 8, height = 6)
plot(accumcurve_mt_polya, add = FALSE, ci.type = "poly", col = "#8ba494", lwd = 2, ci = 0.2, ci.lty = 1, ci.col = "#8ba494")
text(max(accumcurve_mt_polya$sites), max(accumcurve_mt_polya$richness), labels = paste("Slope RNA polyA:", round(slope_mt_polya, 3)), adj = 1)
#dev.off()  # Close the PDF device
#Perfect. Solid supplementary figure.
```

```{r Upset plots and quality comparisons per data stream}
#For this otu table, i re-clustered all vOTUs from the Single assemblies that went into the figures above.

upset_otu_table = read.csv(file="/methods_comparisons/upset_plots/otu_table_filtered_reordered.csv", header=T, sep=',', row.names = 1)

#Ok so now I am really interested in trying to find the overlap of these vOTUs across the samples (i.e., how many are unique per data type / redundant). Going to just aggregate all of the vOTUs per sample-type first. Note again: This is not including the co-assembly unique vOTUs. Those i will just implement into the ecology portion of the paper.

#Now I'm going to split them up into multiple data streams.
mg_bacterial_clust = upset_otu_table %>%
  select(1:8)

mg_total_clust = upset_otu_table %>%
  select(9:20)

mg_eukfloat_clust = upset_otu_table %>%
  select(21:33)

mg_virome_clust = upset_otu_table %>%
  select(34:44)

mt_bulk_clust = upset_otu_table %>%
  select(45:57)

mt_virome_clust = upset_otu_table %>%
  select(58:70)

mt_polya_clust = upset_otu_table %>%
  select(71:82)

#Now, i'm converting this into presence absence. The question is whether the virus OTU is detected across methods or not, not how many of them are within each (i.e., 1x vOTU twice). 

DNA_bacterial_agg = mg_bacterial_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(DNA_bacterial_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, DNA_bacterial_agg)

DNA_total_agg = mg_total_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(DNA_total_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, DNA_total_agg)

DNA_eukfloat_agg = mg_eukfloat_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(DNA_eukfloat_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, DNA_eukfloat_agg)

DNA_virome_agg = mg_virome_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(DNA_virome_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, DNA_virome_agg)

RNA_bulk_agg = mt_bulk_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(RNA_bulk_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, RNA_bulk_agg)

RNA_virome_agg = mt_virome_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(RNA_virome_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, RNA_virome_agg)

RNA_polya_agg = mt_polya_clust %>%
  rownames_to_column(var = "virus_id") %>%
  rowwise() %>%
  mutate(total_abundance = sum(c_across(-virus_id))) %>%
  ungroup() %>%
  mutate(RNA_polya_agg = if_else(total_abundance > 0, 1, 0)) %>%
  select(virus_id, RNA_polya_agg)

aggregated_vOTUs_DNA = DNA_bacterial_agg %>%
  left_join(DNA_eukfloat_agg, by = "virus_id") %>%
  left_join(DNA_total_agg, by = "virus_id") %>%
  left_join(DNA_virome_agg, by = "virus_id") 

aggregated_vOTUs_DNA_2=aggregated_vOTUs_DNA %>%
  column_to_rownames("virus_id")

# Ensure all columns are numeric
aggregated_vOTUs_DNA_2[] = lapply(aggregated_vOTUs_DNA_2, as.numeric)

upset_plot = upset(aggregated_vOTUs_DNA_2, 
      sets = colnames(aggregated_vOTUs_DNA_2),
      keep.order = F,
      order.by = "freq")

#pdf("upset_plot_DNA.pdf", width = 10, height = 8)

# Produce and save the UpSet plot
upset(
  aggregated_vOTUs_DNA_2, 
  sets = colnames(aggregated_vOTUs_DNA_2),
  keep.order = F,
  order.by = "freq"
)

# Close the PDF device
#dev.off()

#Now let's do RNA. 

aggregated_vOTUs_RNA = RNA_polya_agg %>%
  left_join(RNA_virome_agg, by = "virus_id") %>%
  left_join(RNA_bulk_agg, by = "virus_id")
  
  aggregated_vOTUs_RNA_2=aggregated_vOTUs_RNA %>%
  column_to_rownames("virus_id")

# Ensure all columns are numeric
aggregated_vOTUs_RNA_2[] = lapply(aggregated_vOTUs_RNA_2, as.numeric)

upset_plot = upset(aggregated_vOTUs_RNA_2, 
      sets = colnames(aggregated_vOTUs_RNA_2),
      keep.order = T,
      order.by = "freq")

#pdf("upset_plot_RNA.pdf", width = 10, height = 8)

# Produce and save the UpSet plot
upset(
  aggregated_vOTUs_RNA_2, 
  sets = colnames(aggregated_vOTUs_RNA_2),
  keep.order = TRUE,
  order.by = "freq"
)

# Close the PDF device
#dev.off()
  
#Beautiful. There is the upset plot done! Now, i can see the quantities of the viruses, but i want to compare the quality as well

##########################################################

datastream_metadat = read.csv(file="/methods_comparisons/vOTUs_per_data_stream_stats.csv", header=T, sep=',')

quality_table = datastream_metadat %>%
  select(-c(2, 4:7, 11:17, 20))

# Define the desired order of sample types
sampletype_order = c("MG_virome", "MG_EukFloat", "Total_DNA", "MG_bacterial", "MT_Bulk", "MT_virome", "PolyA_RNA")

qual_colors = c("#73c5f6", "#bde673", "#8b9462", "#c5b4c5", "#ff7373")

# Define the desired order of checkv_quality
checkv_quality_order = c("Complete", "High-quality", "Medium-quality", "Low-quality", "Not-determined")

quality_table_agg_df = quality_table %>%
  mutate(sampletype = factor(sampletype, levels = sampletype_order),
         checkv_quality = factor(checkv_quality, levels = checkv_quality_order)) %>%
  group_by(sampletype, checkv_quality) %>%
  summarise(count = n()) %>%
  ungroup()

# Create the proportional plot
proportional_plot = ggplot(quality_table_agg_df, aes(x = sampletype, y = count, fill = checkv_quality)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = qual_colors) +
  labs(title = "Proportional Distribution of vOTUs per Sample Type and CheckV Quality",
       x = "Sample Type",
       y = "Proportion of vOTUs",
       fill = "CheckV Quality") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

proportional_plot

# Create the count plot
count_plot = ggplot(quality_table_agg_df, aes(x = sampletype, y = count, fill = checkv_quality)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = qual_colors) +
  labs(title = "Count of vOTUs per Sample Type and CheckV Quality",
       x = "Sample Type",
       y = "Count of vOTUs",
       fill = "CheckV Quality") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

count_plot

# Arrange the plots side by side
combined_plot = arrangeGrob(proportional_plot, count_plot, ncol = 2)
combined_plot
# Save the combined plots to a PDF file
#ggsave("vOTUs_quality_distributions.pdf", combined_plot, width = 14, height = 7, units = "in")


#### Alright there is quality
###
###

##One last thing here. lets compare the vOTU lengths of the viruses that are shared across at least 2 preparation methods. 

overlapping_vOTUs = read.csv("/methods_comparisons/shared_votu_overlap_lengths.csv", header=T)

# Transforming the data
# Transform the data
long_format_overlaps = overlapping_vOTUs %>%
  # Combine representative_id with clustered_votus into one string
  mutate(all_viruses = paste(representative_id, clustered_votus, sep = ",")) %>%
  # Split into separate virus entries
  separate_rows(all_viruses, sep = ",") %>%
  # Remove duplicates to ensure unique virus entries
  distinct(all_viruses, representative_id, cluster) %>%
  # Select only the virus and group (cluster) columns
  select(virus = all_viruses, group = cluster) %>%
  # Ungroup the dataframe to finalize
  ungroup()

#write.csv(long_format_overlaps, file="long_format_overlaps.csv")

#Did a bunch of merging outside of R because there were a few things that needed tweaking re: IDs. 

# Read the updated CSV file
long_format_overlaps_updated = read.delim("/methods_comparisons/long_format_overlaps_v2.txt", sep = "\t")

# Calculate the average lengths within each cluster and genome_type
avg_lengths = long_format_overlaps_updated %>%
  group_by(group, genome_type, sample_origin) %>%
  summarize(avg_length = mean(length)) %>%
  ungroup()

# Determine the sample_origin with the longest average length in each cluster and genome_type
longest_avg = avg_lengths %>%
  group_by(group, genome_type) %>%
  filter(avg_length == max(avg_length)) %>%
  ungroup()

# Calculate the proportion of clusters where each sample_origin has the highest average length per genome_type
proportions = longest_avg %>%
  group_by(genome_type, sample_origin) %>%
  summarize(count = n()) %>%
  mutate(proportion = count / sum(count)) %>%
  ungroup()

print(proportions)

#let's calculate these out per DNA and RNA separately. I think that makes more sense.
longest_avg_DNA = longest_avg %>%
  filter(grepl("DNA", sample_origin))
  
longest_avg_RNA = longest_avg %>%
  filter(grepl("MT", sample_origin))

proportions_DNA = longest_avg_DNA %>%
  group_by(sample_origin) %>%
  summarize(count = n()) %>%
  mutate(proportion = count / sum(count)) %>%
  ungroup()

print(proportions_DNA)

proportions_RNA = longest_avg_RNA %>%
  group_by(sample_origin) %>%
  summarize(count = n()) %>%
  mutate(proportion = count / sum(count)) %>%
  ungroup()

print(proportions_RNA)

proportions_DNA = proportions_DNA %>%
  mutate(sample_origin = factor(sample_origin, levels = c("Virome_DNA", "EukFloat_DNA", "Total_DNA", "Bacterial_DNA")))

proportions_RNA = proportions_RNA %>%
  mutate(sample_origin = factor(sample_origin, levels = c("MT_Virome", "MT_Bulk", "MT_PolyA")))

proportions_length_DNA = proportions_DNA %>%
  mutate(source = "DNA")

proportions_length_RNA = proportions_RNA %>%
  mutate(source = "RNA")

combined_proportions = bind_rows(proportions_length_DNA, proportions_length_RNA)

#COmbined ggplot
proportion_bars = ggplot(combined_proportions, aes(x = sample_origin, y = proportion, fill = sample_origin)) +
  geom_bar(stat = "identity", alpha = 1) +
  facet_wrap(~source, scales = "free_x") +
  labs(
    title = "Proportion of DNA and RNA methods that contain the longest vOTUs that overlap across methods",
    x = "Sample Origin",
    y = "Proportion of longest vOTU lengths detected"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), # Rotate x labs
    legend.position = "none"
  ) +
  scale_fill_manual(values = c("#73c5f6", "#f0704a", "#ff7bac", "#54bc37","#c5b4c5", "#fedd8d", "#8ba494"))

proportion_bars

#ggsave(proportion_bars, file = "proportion_bars_lengths.pdf")

#I also want to look at not just the lengths, but the actual qualities. letes try someting out here:

#Create numerical mapping for the categorical quality
quality_ranks = c("Low-quality" = 1, "Medium-quality" = 2, "High-quality" = 3, "Complete" = 4)

# Adding a numerical quality score to the dataframe
long_format_overlaps_updated_nums = long_format_overlaps_updated %>%
  mutate(quality_score = quality_ranks[quality])

highest_q_avg_DNA = long_format_overlaps_updated_nums %>%
  filter(grepl("DNA", sample_origin))
  
highest_q_avg_RNA = long_format_overlaps_updated_nums %>%
  filter(grepl("MT", sample_origin))

# Determine the sample_origin with the highest quality score for each group
highest_quality_DNA = highest_q_avg_DNA %>%
  group_by(group) %>%
  filter(quality_score == max(quality_score)) %>% 
  ungroup()

#Need to account for ties here. Add fractional counts if there are ties within groups
ties_resolved_DNA = highest_quality_DNA %>%
  group_by(group) %>%
  mutate(tie_count = n()) %>%
  ungroup()

# Calculate the proportion of clusters where each data stream has the best quality
proportions_quality_DNA = ties_resolved_DNA %>%
  group_by(sample_origin) %>%
  summarize(weighted_count = sum(1 / tie_count), .groups = "drop") %>%
  mutate(proportion = weighted_count / sum(weighted_count))

# Determine the sample_origin with the highest quality score for each group
highest_quality_RNA = highest_q_avg_RNA %>%
  group_by(group) %>%
  filter(quality_score == max(quality_score)) %>% 
  ungroup()

#Need to account for ties here. Add fractional counts if there are ties within groups
ties_resolved_RNA = highest_quality_RNA %>%
  group_by(group) %>%
  mutate(tie_count = n()) %>%
  ungroup()

# Calculate the proportion of clusters where each data stream has the best quality
proportions_quality_RNA = ties_resolved_RNA %>%
  group_by(sample_origin) %>%
  summarize(weighted_count = sum(1 / tie_count), .groups = "drop") %>%
  mutate(proportion = weighted_count / sum(weighted_count))

proportions_quality_DNA = proportions_quality_DNA %>%
  mutate(source = "DNA")

proportions_quality_RNA = proportions_quality_RNA %>%
  mutate(source = "RNA")

# Combine the dataframes while preserving the "source" column
combined_proportions_quality = bind_rows(proportions_quality_DNA, proportions_quality_RNA)

# Transform the sample_origin column into a factor
combined_proportions_quality = combined_proportions_quality %>%
  mutate(sample_origin = factor(sample_origin, levels = c("Virome_DNA", "EukFloat_DNA", "Total_DNA", "Bacterial_DNA", "MT_Virome", "MT_Bulk", "MT_PolyA")))

# Create the bar plot
proportion_bars_quality = ggplot(combined_proportions_quality, aes(x = sample_origin, y = proportion, fill = sample_origin)) +
  geom_bar(stat = "identity", alpha = 1) +
  facet_wrap(~source, scales = "free_x") +
  coord_cartesian(ylim = c(0, 0.8)) +
  labs(
    title = "Proportion of DNA and RNA methods that contain the highest vOTU quality of voTUs that overlap across methods",
    x = "Sample Origin",
    y = "Proportion of highest quality vOTU detected"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), # Rotate x labs
    legend.position = "none"
  ) +
  scale_fill_manual(values = c("#73c5f6", "#f0704a", "#ff7bac", "#54bc37", 
                                "#c5b4c5", "#fedd8d","#8ba494"))

# Display the plot
proportion_bars_quality


#ggsave(proportion_bars_quality, file = "proportion_bars_quality_equalaxes.pdf")

################
################
################

#Per reviewer comments, it also makes sense for this data to look into what the different detection properties of each dataset are. in other words, mapping the reads from each method to the reference database of all the viruses. A lower / easier way to detect a vOTU. reading in the combined output file and then doing some boxplots with whiskers with them.

mapping_detection = read.delim("/read_mapping_results/detection_analyses/filtered_coverM_counts_individual_samps_to_19769_ref.txt", sep = "\t", header = T, row.names = 1)

#let's make this binary - i dont totally want to compare total abundances. at least not yet. (i did this already and it looked kinda meh. Virome -> fungal -> bacterial -> total)

#If we want to remove the sampels that we now just sort of failed we can add this code back in
binary_detection = mapping_detection %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0))) #%>%
#  select(-c(SM1001_MG_virome_NZAGW_scaffold_mapping_98id_primary_refsorted_contam, #SM1002_MG_virome_NZAGX_scaffold_mapping_98id_primary_refsorted_contam))

detection_long = binary_detection %>%
  pivot_longer(cols = everything(), 
               names_to = "Sample_ID", 
               values_to = "Detection") %>%
  mutate(Group = case_when(
    str_detect(Sample_ID, "MG_fungal") ~ "Fungal",
    str_detect(Sample_ID, "MG_virome") ~ "Virome",
    str_detect(Sample_ID, "bacterial") ~ "Bacterial",
    str_detect(Sample_ID, "MG_totalDNA") ~ "Total DNA",
    TRUE ~ "Other"
  ))

detection_summary = detection_long %>%
  group_by(Sample_ID, Group) %>% # Group by Sample ID and Group
  summarize(Total_Detected_vOTUs = sum(Detection), .groups = "drop") #Sum Detection values for each sample- want to see what overall distribution is

#organize them in desc (i peeked at plot prior)
detection_summary$Group = factor(detection_summary$Group, 
                                   levels = c("Virome", "Fungal", "Total DNA", "Bacterial"))

# Create the ggplot with summarized data
ggplot(detection_summary, aes(x = Group, y = Total_Detected_vOTUs, fill = Group)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  scale_color_manual(values = c("#73c5f6", "#f0704a", "#ff7bac", "#54bc37")) +
  scale_fill_manual(values = c("#73c5f6", "#f0704a", "#ff7bac", "#54bc37")) +
  labs(
    title = "Total Number of Detected vOTUs per Sample Across Groups",
    x = "Group",
    y = "Total Detected vOTUs",
    color = "Group"
  ) +
  theme_minimal() +
  theme(legend.position = "right")

#one more thing here. Lets remake these boxplots but where the detection is normalized for the overall sampling effort (i.e., how many reads each sample had).

sampling_metadata = read.delim("/read_mapping_results/sampling_metadata_seqs.csv", sep = ",")

detection_summary_Norm = detection_long %>%
  group_by(Sample_ID, Group) %>% # Group by Sample ID and Group
  summarize(Total_Detected_vOTUs = sum(Detection), .groups = "drop") %>%
  left_join(sampling_metadata, by= "Sample_ID") %>%
  select(-c(4:10, 12:13)) %>%
  mutate(Normalized_vOTUs = Total_Detected_vOTUs / sample_size_qcnumreads)

detection_summary_Norm$Group = factor(detection_summary_Norm$Group, 
                                   levels = c("Virome", "Fungal", "Total DNA", "Bacterial"))

# Create the ggplot with summarized data
detection_box = ggplot(detection_summary_Norm, aes(x = Group, y = Normalized_vOTUs, fill = Group)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  scale_color_manual(values = c("#73c5f6", "#f0704a", "#ff7bac", "#54bc37")) +
  scale_fill_manual(values = c("#73c5f6", "#f0704a", "#ff7bac", "#54bc37")) +
  labs(
    title = "Total Number of Detected vOTUs per Sample Across Groups",
    x = "Group",
    y = "Sample Depth Normalized Total Detected vOTUs",
    color = "Group"
  ) +
  theme_minimal() +
  theme(legend.position = "right")

detection_box

#ggsave(detection_box, file = "normalized_boxplots_DNA.pdf")

#That's pretty cool. Now is it because the viruses are non-overlapping or beacuse the same viruses are found across most? or whats the deal here. Let's do an NMDS to find out on the binary matrix.

#Let's remove the two bad samples that i know the viromes had. They just didn't assemble well and essentially failed. 

binary_detection_sub = binary_detection %>%
  select(-c(SM1001_MG_virome_NZAGW_scaffold_mapping_98id_primary_refsorted_contam, SM1002_MG_virome_NZAGX_scaffold_mapping_98id_primary_refsorted_contam))


Ord_binary_detection=metaMDS(t(binary_detection_sub), distance = "bray", noshare = T, trace = 1, autotransform=T) #make distance matrix
stressplot(Ord_binary_detection) #look weird but probably fine. groups very diff which is what we would hope.

Ord_Ord_binary_detection.scores = as.data.frame(vegan::scores(Ord_binary_detection)$sites)

Ord_Ord_binary_detection.scores_forPlot = Ord_Ord_binary_detection.scores %>%
  rownames_to_column(var = "Sample_ID") %>%
    mutate(Group = case_when(
    str_detect(Sample_ID, "MG_fungal") ~ "Fungal",
    str_detect(Sample_ID, "MG_virome") ~ "Virome",
    str_detect(Sample_ID, "bacterial") ~ "Bacterial",
    str_detect(Sample_ID, "MG_totalDNA") ~ "Total DNA",
    TRUE ~ "Other"))

NMDS_methods_detection_comps_DNA = Ord_Ord_binary_detection.scores_forPlot %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(color=Group), size = 8) +
  stat_ellipse(aes(fill = Group, color = Group), geom = "polygon", alpha = 0.1, level = 0.90) +
  scale_fill_manual(values = c("#54bc37", "#f0704a", "#ff7bac", "#73c5f6")) +
  theme_bw() +
  labs(title="NMDS of viral detection across data streams")

NMDS_methods_detection_comps_DNA

#ggsave(NMDS_methods_detection_comps_DNA, file = "nmds_detection.pdf", width = 12, height = 8)

#QUick stats:

binary_detection_sub_nozero = binary_detection_sub %>%
  filter(rowSums(across(where(is.numeric), ~ . > 0)) > 0)

sampling_metadata_DNA = sampling_metadata %>%
  filter(grepl("DNA", data_stream)) %>%
  filter(!grepl("SM1001_MG_virome_NZAGW_scaffold_mapping_98id_primary_refsorted_contam", Sample_ID)) %>%
  filter(!grepl("SM1002_MG_virome_NZAGX_scaffold_mapping_98id_primary_refsorted_contam", Sample_ID))

dm.vOTUs_dna_abund=calc_dm(binary_detection_sub, method = "bray")
adonis2(formula = dm.vOTUs_dna_abund ~ data_stream, data = sampling_metadata_DNA, permutations = 999)

##########
###########
#########

#Now letsdo this for RNA

mapping_detection_RNA = read.delim("/read_mapping_results/detection_analyses/RNA_vOTUs/RNA_vOTU_output_abundance_counts_combined.tsv", sep = "\t", header = T, row.names = 1)

mapping_detection_RNA = mapping_detection_RNA %>%
  select(-c(1:3)) #cleanup

#let's make this binary - i dont totally want to compare total abundances.

binary_detection = mapping_detection_RNA %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))

detection_long = binary_detection %>%
  pivot_longer(cols = everything(), 
               names_to = "Sample_ID", 
               values_to = "Detection") %>%
  mutate(Group = case_when(
    str_detect(Sample_ID, "MT_bulk") ~ "Bulk",
    str_detect(Sample_ID, "MT_polyA") ~ "PolyA",
    str_detect(Sample_ID, "MT_virome") ~ "Virome",
    TRUE ~ "Other"
  ))

detection_summary = detection_long %>%
  group_by(Sample_ID, Group) %>% # Group by Sample ID and Group
  summarize(Total_Detected_vOTUs = sum(Detection), .groups = "drop") #Sum Detection values for each sample- want to see what overall distribution is

#organize them in desc (i peeked at plot prior)
detection_summary$Group = factor(detection_summary$Group, 
                                   levels = c("Virome", "Bulk", "PolyA"))

# Create the ggplot with summarized data
ggplot(detection_summary, aes(x = Group, y = Total_Detected_vOTUs, fill = Group)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  scale_color_manual(values = c("#c5b4c5", "#fedd8d", "#8ba494")) +
  scale_fill_manual(values = c("#c5b4c5", "#fedd8d", "#8ba494")) +
  labs(
    title = "Total Number of Detected vOTUs per Sample Across Groups",
    x = "Group",
    y = "Total Detected vOTUs",
    color = "Group"
  ) +
  theme_minimal() +
  theme(legend.position = "right")

#one more thing here. Lets remake these boxplots but where the detection is normalized for the overall sampling effort (i.e., how many reads each sample had).

sampling_metadata = read.delim("/read_mapping_results/sampling_metadata_seqs.csv", sep = ",")

detection_summary_Norm = detection_long %>%
  group_by(Sample_ID, Group) %>% # Group by Sample ID and Group
  summarize(Total_Detected_vOTUs = sum(Detection), .groups = "drop") %>%
  left_join(sampling_metadata, by= "Sample_ID") %>%
  select(-c(4:10, 12:13)) %>%
  mutate(Normalized_vOTUs = Total_Detected_vOTUs / sample_size_qcnumreads)

detection_summary_Norm$Group = factor(detection_summary_Norm$Group, 
                                   levels = c("Virome", "Bulk", "PolyA"))

# Create the ggplot with summarized data
detection_box = ggplot(detection_summary_Norm, aes(x = Group, y = Normalized_vOTUs, fill = Group)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  scale_color_manual(values = c("#c5b4c5", "#fedd8d", "#8ba494")) +
  scale_fill_manual(values = c("#c5b4c5", "#fedd8d", "#8ba494")) +
  labs(
    title = "Total Number of Detected vOTUs per Sample Across Groups",
    x = "Group",
    y = "Sample Depth Normalized Total Detected vOTUs",
    color = "Group"
  ) +
  theme_minimal() +
  theme(legend.position = "right")

detection_box

#ggsave(detection_box, file = "normalized_boxplots_RNA.pdf")

#That's pretty cool. Now is it because the viruses are non-overlapping or beacuse the same viruses are found across most? or whats the deal here. Let's do an NMDS to find out on the binary matrix.

#Let's remove the two bad samples that i know the viromes had. They just didn't assemble well and essentially failed. 

Ord_binary_detection=metaMDS(t(binary_detection), distance = "bray", noshare = T, trace = 1, autotransform=T) #make distance matrix
stressplot(Ord_binary_detection) #look weird but probably fine. groups very diff which is what we would hope.

Ord_Ord_binary_detection.scores = as.data.frame(vegan::scores(Ord_binary_detection)$sites)

Ord_Ord_binary_detection.scores_forPlot = Ord_Ord_binary_detection.scores %>%
  rownames_to_column(var = "Sample_ID") %>%
  mutate(Group = case_when(
    str_detect(Sample_ID, "MT_bulk") ~ "Bulk",
    str_detect(Sample_ID, "MT_polyA") ~ "PolyA",
    str_detect(Sample_ID, "MT_virome") ~ "Virome",
    TRUE ~ "Other"))

NMDS_methods_detection_comps_RNA = Ord_Ord_binary_detection.scores_forPlot %>%
  ggplot(aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(color=Group), size = 8) +
  stat_ellipse(aes(fill = Group, color = Group), geom = "polygon", alpha = 0.1, level = 0.90) +
  scale_color_manual(values = c("#fedd8d", "#8ba494", "#c5b4c5")) +
  theme_bw() +
  labs(title="NMDS of viral detection across data streams")

NMDS_methods_detection_comps_RNA

#ggsave(NMDS_methods_detection_comps_RNA, file = "nmds_RNA_detection.pdf", width = 9, height = 8)


#quick stats

binary_detection_sub_nozero = binary_detection %>%
  filter(rowSums(across(where(is.numeric), ~ . > 0)) > 0)

sampling_metadata_RNA = sampling_metadata %>%
  filter(grepl("RNA", data_stream))

dm.vOTUs_rna_abund=calc_dm(binary_detection_sub_nozero, method = "bray")
adonis2(formula = dm.vOTUs_rna_abund ~ data_stream, data = sampling_metadata_RNA, permutations = 999)

```

``` {r Virus-Host Links}

#Let's do DNA
variables_to_keep5 = c("datastream_metadat", "relabund_dna_abund_genome", "geTMM_dna_expression_genome", "relabund_rna_abundance_genome", "jaccard_rna_expression", "sample_metadata") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep5)) #clean out the environment

dnahosts = read.delim("/iPHoP/iphop_best_hits.csv", header = TRUE, sep=",")

#Group by 'Host phylum' and 'source' and count viruses
grouped = dnahosts %>%
  group_by(phylum, fractionation_method) %>%
  summarise(count = n()) %>%
  ungroup()

# Step 3: Normalize the counts to get proportions
proportions = grouped %>%
  group_by(phylum) %>%
  mutate(proportion = count / sum(count))

source_colors = c("virome" = "#73c5f6", "eukfloat" = "#f0704a", "bacterial" = "#54bc00", "total_DNA" = "#ff7bac")

# Step 4: Create the stacked bar chart with reversed order on y-axis
dna_hosts = ggplot(proportions, aes(x = proportion, y = fct_rev(phylum), fill = fractionation_method)) + 
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = source_colors) +
  labs(
    title = 'Proportion of Viruses per Source for each Host Phylum',
    x = 'Proportion of all viruses',
    y = 'Host Phylum'
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  guides(fill=guide_legend(title="Source"))

dna_hosts
#ggsave(dna_hosts, file = "stacked_barchart_DNA.pdf")

#Now lets do RNA
rnahosts = read.delim("/iPHoP/rna_virus_hosts.csv", header = TRUE, sep=",")

# Remove rows where keep_remove is "remove"
filtered_df = rnahosts[rnahosts$keep_remove != "remove", ]

grouped_rna = filtered_df %>%
  group_by(pred.L1, sample_origin) %>%
  summarise(count = n()) %>%
  ungroup()

#Normalize the counts to get proportions
proportions_rna = grouped_rna %>%
  group_by(pred.L1) %>%
  mutate(proportion = count / sum(count))

# Define the colors (adjust to your RNA sources)
rna_source_colors = c("RNA Virome" = "#c5b4c5", "RNA PolyA" = "#8ba494", "RNA Bulk" = "#fedd8d")

# Step 4: Create the stacked bar chart with reversed order on y-axis
rna_host_predictions = ggplot(proportions_rna, aes(x = proportion, y = fct_rev(pred.L1), fill = sample_origin)) + 
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = rna_source_colors) +
  labs(
    title = 'Proportion of Viruses per Sample Origin for each Pred.L1',
    x = 'Proportion of all viruses',
    y = 'Pred.L1'
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1)
  ) +
  guides(fill=guide_legend(title="Sample Origin"))

rna_host_predictions
#ggsave(plot = rna_host_predictions, "rna_host_predictions_proportions_v2.pdf", height = 6, width = 6)

#Ok i really like these, but now i also want to show the total proportion per each data stream overall of each.

#DNA first
# Step 2: Group by 'Host phylum' and 'source' and count viruses
grouped = dnahosts %>%
  group_by(phylum, fractionation_method) %>%
  summarise(count = n()) %>%
  ungroup()

# Step 3: Normalize the counts to get proportions
proportion_ids = grouped %>%
  group_by(fractionation_method) %>%
  mutate(proportion = count / sum(count))

# Define the colors
host_phylum_colors = c("#5a2952", "#6abdcd","#ee83b4",  "#b4cd6a","#4acda4","#e69420","#7383a4","#83acf6","#ffb6c1", "#c5ac8b", "#de4129", "black")

# Step 1: Define threshold for grouping as "Other"
threshold = 0.01

# Step 2: Identify phylum below the threshold for each fractionation method
small_phyla = proportion_ids %>%
  group_by(fractionation_method) %>%
  filter(proportion < threshold)

# Step 3: Calculate the total proportion for "Other" for each fractionation method
other_proportions = small_phyla %>%
  group_by(fractionation_method) %>%
  summarise(proportion = sum(proportion)) %>%
  mutate(phylum = "Other")

# Step 4: Combine the "Other" category with larger phyla
proportions_modified = proportion_ids %>%
  filter(proportion >= threshold) %>% # Keep original phyla above the threshold
  bind_rows(other_proportions)        # Add the "Other" category

# Step 5: Convert `phylum` back to factor to ensure levels are sorted correctly
proportions_modified$phylum = factor(proportions_modified$phylum, levels = c(sort(unique(proportions$phylum)), "Other"))

# Step 6: Create the plot with modified data
dnaprops = ggplot(proportions_modified, aes(x = fractionation_method, y = proportion, fill = phylum)) + 
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = host_phylum_colors) +
  labs(
    title = 'Proportion of Host Phylum per Source',
    x = 'Source',
    y = 'Proportion of all viruses'
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5)
  ) +
  guides(fill=guide_legend(title="Host Phylum"))

dnaprops

#ggsave(dnaprops, file="DNA_props_barsSOM_wOther.pdf")

# Lets do this for RNA.
# Calculate total counts per sample_origin
total_counts = aggregate(counts ~ sample_origin, data = filtered_df, sum)
colnames(total_counts) = c("sample_origin", "total_counts")

# Merge total_counts back to filtered_df
merged_df = merge(filtered_df, total_counts, by = "sample_origin")

# Calculate proportion
merged_df$proportion = merged_df$counts / merged_df$total_counts

rna_host_phylum_colors = c("#7c767c", "#bfada0","#d4004d",  "#caff9f","#ffbff5")

# Create the stacked bar chart
rna_host_predictions = ggplot(data = merged_df, aes(x = sample_origin, y = proportion, fill = pred.L1)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = rna_host_phylum_colors) +
  labs(title = "Proportion of Counts by Predicted Host within Each Sample Origin",
       x = "Sample Origin", y = "Proportion", fill = "Predicted Host") +
  theme_minimal()

rna_host_predictions

```

```{r Richness Plots per Method}

#Now i want to make the richness / counts of each vOTU across each dataset. Using the geaParser, i'm able to discriminate between reads mapped to coding / template strand and those mapping to non-coding / expressed strand of the RNA seq data. I now have full vOTU tables that represent "counts" of each vOTU per sample per data method. Reading these in.

mg_bacterial_counts = read.delim("/methods_comparisons/abundance_mapping_per_method/bacterial_filtered_coverM_counts.txt", header = T, sep="\t", row.names = 1)

mg_eukfloat_counts = read.delim("/methods_comparisons/abundance_mapping_per_method/fungal_filtered_coverM_counts.txt", header = T, sep="\t", row.names = 1)

total_DNA_counts = read.delim("/methods_comparisons/abundance_mapping_per_method/total_filtered_coverM_counts.txt", header = T, sep="\t", row.names = 1)

mg_virome_counts = read.delim("/methods_comparisons/abundance_mapping_per_method/virome_filtered_coverM_counts.txt", header = T, sep="\t", row.names = 1)

mg_virome_counts = mg_virome_counts %>%
  select(-c(SM1001_MG_virome_NZAGW_scaffold_mapping_98id_primary_sorted, SM1002_MG_virome_NZAGX_scaffold_mapping_98id_primary_sorted)) #these two samples are pretty bad outliers because they did not get much viruses. pulling them out.

mt_bulk_counts = read.delim("/methods_comparisons/abundance_mapping_per_method/vOTU_output_abundance_counts_parsed_RNA_bulkMetaT_3862.tsv", header = T, sep="\t", row.names = 1)

mt_virome_counts = read.delim("/methods_comparisons/abundance_mapping_per_method/vOTU_output_abundance_counts_parsed_RNA_Virome_3787.tsv", header = T, sep="\t", row.names = 1)

mt_polya_counts = read.delim("/methods_comparisons/abundance_mapping_per_method/vOTU_output_abundance_counts_parsed_RNA_PolyA_372.tsv", header = T, sep="\t", row.names = 1)

# Define a function to calculate richness, diversity, and evenness
calculate_metrics = function(otu_table, method_name) {
  richness = colSums(otu_table > 0)
  shannon = diversity(t(otu_table), index = "shannon")
  pielou = shannon / log(richness)
  tibble(
    sample_id = colnames(otu_table),
    richness = richness,
    shannons = shannon,
    pielous = pielou,
    method = method_name
  )
}

# Calculate metrics for each OTU table
methods = list(mg_bacterial_counts = "bacterial",
                mg_eukfloat_counts = "eukfloat",
                mg_virome_counts = "virome",
                mt_bulk_counts = "mt_bulk",
                mt_virome_counts = "mt_virome",
                mt_polya_counts = "mt_polya",
                total_DNA_counts = "total_dna")

metrics_list = lapply(names(methods), function(otu_table_name) {
  calculate_metrics(get(otu_table_name), methods[[otu_table_name]])
})

# Combine all metrics into a single data frame
metrics_combined_individual_datasets = bind_rows(metrics_list)

##############

# Bring in Moisture data
moisture_per_sample = read.csv("/_Supplemental_Tables/split/site_metadata.csv", sep = ",", header = T)

# Add moisture data to metrics_combined
metrics_combined = metrics_combined_individual_datasets %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

source_colors = c("virome" = "#73c5f6", "eukfloat" = "#f0704a", "bacterial" = "#54bc00", "total_dna" = "#ff7bac", "mt_virome" = "#c5b4c5" , "mt_bulk" = "#fedd8d", "mt_polya" = "#8ba494")

# Create Richness plot
richness_plot = ggplot(metrics_combined, aes(x = percent_water_content, y = richness, color = method)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = FALSE, aes(group = method), linetype = "solid") +
  labs(
    title = "Richness vs. Moisture Content by Method",
    y = "Richness (Number of Unique OTUs)",
    x = "Moisture Content (%)",
    color = "Method"
  ) +
  theme_minimal() +
  scale_color_manual(values = source_colors) +
  facet_wrap(~ method, scales = "free") +
  theme(
    axis.text.x = element_text(hjust = 1) # Rotate x-axis text
  ) +
  scale_x_continuous(
    breaks = seq(0.11, 0.17, by = 0.02) # Specify ticks every other value
  )

richness_plot
#ggsave(richness_plot, file="richness_plots_v3.pdf")

#I want some more stats here to make it more robust. Lets run some linear models on each method so i can get the values that the line is showing in the plots above.
# Prepare the dataset (assuming metrics_combined is already defined)

metrics_combined = metrics_combined %>%
  mutate(method = factor(method))  # Ensure `method` is treated as a factor

# Function to fit and test a linear model for each method
fit_and_test_lm = function(data) {
  lm_fit = lm(percent_water_content ~ richness, data = data)
  tidy(lm_fit) %>%
    filter(term == "richness")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_richness = metrics_combined %>%
  group_by(method) %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm)) %>%
  unnest(model_results)

# Create Shannon's Diversity Index plot
shannon_plot = ggplot(metrics_combined, aes(x = percent_water_content, y = shannons, color = method)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = FALSE, aes(group = method), linetype = "solid") +
  labs(
    title = "Shannons vs. Moisture Content by Method",
    y = "Shannons",
    x = "Moisture Content (%)",
    color = "Method"
  ) +
  theme_minimal() +
  scale_color_manual(values = source_colors) +
  facet_wrap(~ method, scales = "free")

shannon_plot
#ggsave(shannon_plot, file="shannon_plots.pdf")

# Function to fit and test a linear model for each method
fit_and_test_lm_shannons = function(data) {
  lm_fit = lm(percent_water_content ~ shannons, data = data)
  tidy(lm_fit) %>%
    filter(term == "shannons")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_shannons = metrics_combined %>%
  group_by(method) %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_shannons)) %>%
  unnest(model_results)

# Create Pielou's Evenness Index plot
pielous_plot = ggplot(metrics_combined, aes(x = percent_water_content, y = pielous, color = method)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = FALSE, aes(group = method), linetype = "solid") +
  labs(
    title = "Pielous vs. Moisture Content by Method",
    y = "Pielous",
    x = "Moisture Content (%)",
    color = "Method"
  ) +
  theme_minimal() +
  scale_color_manual(values = source_colors) +
  facet_wrap(~ method, scales = "free")

pielous_plot

#ggsave(pielous_plot, file="pielou_plots.pdf")
       
# Function to fit and test a linear model for each method
fit_and_test_lm_pielous = function(data) {
  lm_fit = lm(percent_water_content ~ pielous, data = data)
  tidy(lm_fit) %>%
    filter(term == "pielous")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_pielous = metrics_combined %>%
  group_by(method) %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_pielous)) %>%
  unnest(model_results)


```

```{r Ecology Analyses: Normalized Expression and Ordinations}

#Let's clean this up from the last stuff. 

variables_to_keep4 = c("moisture_per_sample", "metrics_combined") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep4)) #clean out the environment - keeping the metadata

#Now we're going to start working with the fully de-replicated database across all data methods. I mapped these three ways. 1. DNA vOTUs to bulk metaT (dna expression) 2. DNA vOTUs to dna virome (dna abundance) 3. RNA vOTUs to bulk metaT (rna abundance and expression). The latter file (3) i then used geaParser to determine if reads mapped to template strand (abundance) or non-template strand (expression). These are only ssRNA + or - viruses so these should be accurate. I did get a handful of clobbers that said certain vOTUs were expressed but not abundant - i removed those small fraction of vOTUs because i think those are more likely methodological detection issues that did not make the 1x depth and 75% coverage cutoff.

#DNA abundance 
counts_dna_abund = read.delim("/read_mapping_results/ecology_analyses/bulk_metaG_DNA_vOTU/TotalDNA_consolidatedDB_filtered_coverM_counts.txt", header = T, sep="\t") #coverM out

#Processing dna abund coverM table. This already has 1x depth cutoff and 75% coverage cutoff implemented.
relabund_dna_abund_genome = counts_dna_abund %>%
  column_to_rownames("Contig") %>%
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) #%>% # Remove rows with zero across all samples
  #rownames_to_column(var = "Contig")

#write.csv(relabund_dna_abund_genome, file="relabund_DNA_vOTU_abunds.csv")

#Going to make a plot here showing dna abundance across the samples and total number of dna viruses that are abundant by moisture.

dna_summed_abund_votus_persamps = counts_dna_abund %>%
  pivot_longer(cols = -Contig, names_to = "sample_id", values_to = "Abundance") %>%
  filter(Abundance != 0) %>%  # Remove rows with zero values
  group_by(sample_id) %>% #group by sample
  summarise(total_abundance = sum(Abundance, na.rm = TRUE), .groups = "drop") %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

overallabundDNA = ggplot(dna_summed_abund_votus_persamps, aes(y = total_abundance, x = percent_water_content, colour = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(y = total_abundance, x = percent_water_content)) +
  labs(
    title = "Abundance vs. Moisture Content",
    y = "DNA vOTU Abundance (summed counts)",
    x = "Moisture Content (%)",
    color = "Moisture Content (%)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) +
  scale_colour_viridis_c(option = "mako", name = "Moisture Content (%)", direction = 1)

overallabundDNA

#ggsave(overallabundDNA, file="Abundance_Through_Moisture.pdf", height = 8, width = 10)

# Function to fit and test a linear model for each method
fit_and_test_lm_abundDNA = function(data) {
  lm_fit = lm(percent_water_content ~ total_abundance, data = data)
  tidy(lm_fit) %>%
    filter(term == "total_abundance")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_abundDNA_res = dna_summed_abund_votus_persamps %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_abundDNA)) %>%
  unnest(model_results)

#####

dna_num_abund_votus_persamps = relabund_dna_abund_genome %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "fullsample", values_to = "Abundance") %>%
  filter(Abundance > 0) %>%
  group_by(fullsample) %>%
  summarise(Abund_vOTUs = n_distinct(votu_id), .groups = 'drop') %>%
  mutate(sample = sub("_(MG|MT).*", "", fullsample)) %>%
  left_join(select(moisture_per_sample, sample, percent_water_content), by = "sample")

overallabundCountsDNA = ggplot(dna_num_abund_votus_persamps, aes(y = Abund_vOTUs, x = percent_water_content, colour = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(y = Abund_vOTUs, x = percent_water_content)) +
  labs(
    title = "Abund Counts vs. Moisture Content",
    y = "Total abundant vOTUs",
    x = "Moisture Content (%)",
    color = "Moisture Content (%)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) +
  scale_colour_viridis_c(option = "mako", name = "Moisture Content (%)", direction = 1)

overallabundCountsDNA

#ggsave(overallabundCountsDNA, file="Abundant_Counts_Through_Moisture.pdf", height = 8, width = 10)

# Function to fit and test a linear model for each method
fit_and_test_lm_countsDNA = function(data) {
  lm_fit = lm(percent_water_content ~ Abund_vOTUs, data = data)
  tidy(lm_fit) %>%
    filter(term == "Abund_vOTUs")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_countsDNA_res = dna_num_abund_votus_persamps %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_countsDNA)) %>%
  unnest(model_results)


####
###
###

#Now lets do the diversity stats
# Define a function to calculate richness, diversity, and evenness
calculate_metrics = function(otu_table) {
  richness = colSums(otu_table > 0) # Count non-zero vOTUs per sample
  shannon = diversity(t(otu_table), index = "shannon") # Shannon diversity
  pielou = shannon / log(richness) #Pielou's evenness
  tibble(
    sample_id = colnames(otu_table),
    richness = richness,
    shannons = shannon,
    pielous = pielou
  )
}

metrics = calculate_metrics(relabund_dna_abund_genome)

# Add moisture data to metrics_combined
metrics_combined_Full_DNA = metrics %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

# Create Richness plot
richness_plot = ggplot(metrics_combined_Full_DNA, aes(x = percent_water_content, y = richness, colour = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(x = percent_water_content, y = richness)) +
  labs(
    title = "Richness vs. Moisture Content by Method",
    y = "Richness (Number of Unique OTUs)",
    x = "Moisture Content (%)",
    color = "Percent Water Content"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1))

richness_plot

#ggsave(richness_plot, file="richness_plot_consolidated.pdf", height = 8, width = 10)

#I want some more stats here to make it more robust. Lets run some linear models on each method so i can get the values that the line is showing in the plots above.
# Prepare the dataset (assuming metrics_combined is already defined)

# Function to fit and test a linear model for each method
fit_and_test_lm = function(data) {
  lm_fit = lm(percent_water_content ~ richness, data = data)
  tidy(lm_fit) %>%
    filter(term == "richness")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_richness = metrics_combined_Full_DNA %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm)) %>%
  unnest(model_results)

# Create Shannon's Diversity Index plot
shannon_plot = ggplot(metrics_combined_Full_DNA, aes(x = percent_water_content, y = shannons, color = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(x = percent_water_content, y = shannons)) +
  labs(
    title = "Shannons vs. Moisture Content by Method",
    y = "Shannons",
    x = "Moisture Content (%)",
    color = "Moisture Content (%)"
  ) +
  theme_minimal()

shannon_plot
#ggsave(shannon_plot, file="shannon_plots_consolidated.pdf", height = 8, width = 10)

# Function to fit and test a linear model for each method
fit_and_test_lm_shannons = function(data) {
  lm_fit = lm(percent_water_content ~ shannons, data = data)
  tidy(lm_fit) %>%
    filter(term == "shannons")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_shannons = metrics_combined_Full_DNA %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_shannons)) %>%
  unnest(model_results)

# Create Pielou's Evenness Index plot
pielous_plot = ggplot(metrics_combined_Full_DNA, aes(x = percent_water_content, y = pielous, color = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(x = percent_water_content, y = pielous)) +
  labs(
    title = "Pielous vs. Moisture Content by Method",
    y = "Pielous",
    x = "Moisture Content (%)",
    color = "Moisture Content (%)"
  ) +
  theme_minimal() 

pielous_plot

#ggsave(pielous_plot, file="pielou_plots_consolidated.pdf", height = 8, width = 10)
       
# Function to fit and test a linear model for each method
fit_and_test_lm_pielous = function(data) {
  lm_fit = lm(percent_water_content ~ pielous, data = data)
  tidy(lm_fit) %>%
    filter(term == "pielous")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_pielous = metrics_combined_Full_DNA %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_pielous)) %>%
  unnest(model_results)

#DNA expression
counts_dna_expression = read.delim("/read_mapping_results/ecology_analyses/bulk_metaT_DNA_vOTU/featureCounts_output_CDS_reverse-stranded_paired.txt") #featureCounts out

counts_dna_expression_noZero =  counts_dna_expression %>% 
  filter(rowSums(select(., 7:19)) != 0) %>% #Remove rows where the sum of the values in columns 7 to 19 is zero - just to make the processing quicker.
  mutate(across(7:19, ~ ifelse(. < 5, 0, .))) %>% #Replace counts less than 5 with zero. Minimum of 5 counts per gene.
  filter(rowSums(select(., 7:19)) != 0) %>% #Re-filter out any gene that is completely zero
  select(-Chr, -Start, -End, -Strand) %>% #Remove a few cols.
  column_to_rownames("Geneid")

#calculate RPK
rpk_metaT_dna = ((counts_dna_expression_noZero[,2:14]*10^3)/counts_dna_expression_noZero[,1]) #note, we multiply by 10^3 here because geTMM expects kilobase pairs on lengths and featurecounts_dna_expression reports bps.
group_metaT_dna = c(rep("A",ncol(rpk_metaT_dna)))

#Just to plot out the overall expression, i'm summing these up per moisture and adding them
# Reshape the data to long format using pivot_longer
rpk_metaT_dna_long = rpk_metaT_dna %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "sample_id", values_to = "expression") %>%
  filter(expression != 0) %>%  # Remove rows with zero values
  group_by(sample_id) %>% #group by genome
  summarise(total_expression = sum(expression, na.rm = TRUE), .groups = "drop") %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

# Create the boxplot with specified colors
overallrpkDNA = ggplot(rpk_metaT_dna_long, aes(y = total_expression, x = percent_water_content, colour = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(y = total_expression, x = percent_water_content)) +
  labs(
    title = "Expression vs. Moisture Content",
    y = "DNA vOTU Expression (summed rpk)",
    x = "Moisture Content (%)",
    color = "Moisture Content (%)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) +
  scale_colour_viridis_c(option = "mako", name = "Moisture Content (%)", direction = 1)

overallrpkDNA

#ggsave(overallrpkDNA, file = "DNA_vOTU_RPK.pdf", width = 15, height = 7)

# Function to fit and test a linear model for each method
fit_and_test_lm_expression = function(data) {
  lm_fit = lm(percent_water_content ~ total_expression, data = data)
  tidy(lm_fit) %>%
    filter(term == "total_expression")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_expression_res = rpk_metaT_dna_long %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_expression)) %>%
  unnest(model_results)

#calculate geTMM
rpk.norm_dna = DGEList(counts=rpk_metaT_dna,group=group_metaT_dna)
rpk.norm_dna = calcNormFactors(rpk.norm_dna)
geTMM_norm.counts_dna_expression.rpk_edger = as.data.frame(cpm(rpk.norm_dna))

#now aggregate these at a genome level. Bring back the ids from the original file
geTMM_dna_expression_genome = geTMM_norm.counts_dna_expression.rpk_edger %>%
  rownames_to_column("Geneid") %>%
  left_join(select(counts_dna_expression, Geneid, Chr), by = "Geneid") %>%
  select(-Geneid) %>%
  select(Chr, everything()) %>%
  group_by(Chr) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("Chr")

#write.csv(geTMM_dna_expression_genome, file="geTMM_normalized_DNA_vOTU_expression.csv")

#Lets plot out real quick total number of vOTUs that are active.

#Transpose the dataframe to have samples as rows and OTUs as columns
geTMM_dna_expression_transposed = as.data.frame(t(geTMM_dna_expression_genome))
geTMM_dna_expression_transposed = rownames_to_column(geTMM_dna_expression_transposed, "fullsample")

#Join the moisture information
expressed_otus_moisture = geTMM_dna_expression_transposed %>%
  pivot_longer(cols = starts_with("SM"), names_to = "OTU", values_to = "Expression") %>%
  filter(Expression > 0) %>%
  group_by(fullsample) %>%
  summarise(Expressed_OTUs = n_distinct(OTU), .groups = 'drop') %>%
  mutate(sample = sub("_(MG|MT).*", "", fullsample)) %>%
  left_join(select(moisture_per_sample, sample, percent_water_content), by = "sample")

# Create the scatterplot
expressed_dna_votus = ggplot(expressed_otus_moisture, aes(y = Expressed_OTUs, x = percent_water_content, colour = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(y = Expressed_OTUs, x = percent_water_content)) +
  labs(
    title = "Expression vs. Moisture Content",
    y = "Total active DNA vOTUs",
    x = "Moisture Content (%)",
    color = "Moisture Content (%)"
    ) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) + 
  scale_colour_viridis_c(option = "mako", name = "Moisture Content (%)", direction = 1)

expressed_dna_votus

#ggsave(expressed_dna_votus, file = "DNA_active_vOTU_counts.pdf", width = 15, height = 7)

# Function to fit and test a linear model for each method
fit_and_test_lm_activevotus = function(data) {
  lm_fit = lm(percent_water_content ~ Expressed_OTUs, data = data)
  tidy(lm_fit) %>%
    filter(term == "Expressed_OTUs")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_activevotus_res = expressed_otus_moisture %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_activevotus)) %>%
  unnest(model_results)

#This is the same as my overall expression patterns. This is also opposite to ruonan's trends. interesting.

#RNA abundance
counts_rna_abundance = read.delim("/read_mapping_results/ecology_analyses/bulk_metaT_RNA_vOTU/5893_genes_abundance_vOTUs.csv", header = T, sep=",") #geaParse template strand

#Processing geaParse abund table - resolving at genome level. This already has 1x depth cutoff and 75% coverage cutoff implemented.
relabund_rna_abundance_genome = counts_rna_abundance %>%
  select(-length, -gene_id) %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  mutate_all(~ . / sum(.) * 100) %>% #calc relative abund.
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

relabund_rna_abundance_genome_write = relabund_rna_abundance_genome %>%
  rownames_to_column(var="genome")

#write_csv(relabund_rna_abundance_genome_write, file="relabund_rna_abundance_genome.csv")

Nonrelabund_rna_abundance_genome = counts_rna_abundance %>%
  select(-length, -gene_id) %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  filter(rowSums(.) != 0) # Remove rows with zero across all samples

Nonrelabund_rna_abundance_genome_long = Nonrelabund_rna_abundance_genome %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "sample_id", values_to = "counts")

metrics = calculate_metrics(Nonrelabund_rna_abundance_genome)

# Add moisture data to metrics_combined
metrics_combined_Full_RNA = metrics %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

# Create Richness plot
richness_plot = ggplot(metrics_combined_Full_RNA, aes(x = richness, y = percent_water_content, colour = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(y = percent_water_content, x = richness)) +
  labs(
    title = "Richness vs. Moisture Content by Method",
    x = "Richness (Number of Unique OTUs)",
    y = "Moisture Content (%)",
    color = "Percent Water Content"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(hjust = 1) # Rotate x-axis text
  ) +
  scale_x_continuous(
    breaks = seq(0.11, 0.17, by = 0.02) # Specify ticks every other value
  )

richness_plot

#ggsave(richness_plot, file="richness_plot_consolidated_RNA.pdf", height = 8, width = 10)

#I want some more stats here to make it more robust. Lets run some linear models on each method so i can get the values that the line is showing in the plots above.
# Prepare the dataset (assuming metrics_combined is already defined)

# Function to fit and test a linear model for each method
fit_and_test_lm = function(data) {
  lm_fit = lm(percent_water_content ~ richness, data = data)
  tidy(lm_fit) %>%
    filter(term == "richness")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_richness = metrics_combined_Full_RNA %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm)) %>%
  unnest(model_results)

# Create Shannon's Diversity Index plot
shannon_plot = ggplot(metrics_combined_Full_RNA, aes(x = shannons, y = percent_water_content, color = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(x = shannons, y = percent_water_content)) +
  labs(
    title = "Shannons vs. Moisture Content by Method",
    y = "Shannons",
    x = "Moisture Content (%)",
    color = "Moisture Content (%)"
  ) +
  theme_minimal()

shannon_plot
#ggsave(shannon_plot, file="shannon_plots_consolidated_RNA.pdf", height = 8, width = 10)

# Function to fit and test a linear model for each method
fit_and_test_lm_shannons = function(data) {
  lm_fit = lm(percent_water_content ~ shannons, data = data)
  tidy(lm_fit) %>%
    filter(term == "shannons")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_shannons = metrics_combined_Full_RNA %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_shannons)) %>%
  unnest(model_results)

# Create Pielou's Evenness Index plot
pielous_plot = ggplot(metrics_combined_Full_RNA, aes(x = pielous, y = percent_water_content, color = percent_water_content)) +
  geom_point(size = 8) +
  geom_smooth(method = "lm", se = F, linetype = "solid", inherit.aes = FALSE, aes(y = percent_water_content, x = pielous)) +
  labs(
    title = "Pielous vs. Moisture Content by Method",
    y = "Pielous",
    x = "Moisture Content (%)",
    color = "Moisture Content (%)"
  ) +
  theme_minimal() 

pielous_plot

#ggsave(pielous_plot, file="pielou_plots_consolidated_RNA.pdf", height = 8, width = 10)
       
# Function to fit and test a linear model for each method
fit_and_test_lm_pielous = function(data) {
  lm_fit = lm(percent_water_content ~ pielous, data = data)
  tidy(lm_fit) %>%
    filter(term == "pielous")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
lm_results_pielous = metrics_combined_Full_RNA %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_pielous)) %>%
  unnest(model_results)

#RNA expression
counts_rna_expression = read.delim("/read_mapping_results/ecology_analyses/bulk_metaT_RNA_vOTU/5893_genes_expression_vOTUs.csv", header = T, sep=",") #geaParse non-template strand

jaccard_rna_expression = counts_rna_expression %>%
  select(-length, -gene_id) %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0))) %>%
  filter(rowSums(.) != 0) %>% # Remove rows with zero across all samples
  rownames_to_column("scaffold_id")

#write.csv(jaccard_rna_expression, file="jaccard_RNA_expression.csv")

#Alright - now let's do a left merge of this pres/abs to the abundance values of the viruses so that i can get overall abundance / number of active RNA vOTUs

relabund_rna_abundance_genome_toMerge = relabund_rna_abundance_genome %>%
  rownames_to_column(var="scaffold_id")

#write.csv(jaccard_rna_expression, file="Overall_jaccard_RNA_expression.csv")

#write.csv(Nonrelabund_rna_abundance_genome, file="Overall_nonrelabund_rna_abundance_genome.csv")

#r sucks and this doesnt work because r sucks writing this out and doing this in python i give up.

#RNA_expressed_abundProxy = jaccard_rna_expression %>%
#  select(c(scaffold_id)) %>%
#  left_join(relabund_rna_abundance_genome_toMerge, by="scaffold_id") %>%
#  column_to_rownames(var="scaffold_id")

Overall_jaccard_expression_proxy = read.csv("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/processed_RNA_vOTU_tabs/Updated_jaccard_proxy_nonrel_expression.csv", header = T, row.names = 1)

#calculate RPK
rpk_metaT_rna_Overall = ((Overall_jaccard_expression_proxy[,2:14]*10^3)/Overall_jaccard_expression_proxy[,1]) #note, we multiply by 10^3 here because geTMM expects kilobase pairs on lengths and featurecounts_dna_expression reports bps.

Overall_jaccard_expression_proxy_long = rpk_metaT_rna_Overall %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "sample_id", values_to = "abundance") %>%
  group_by(sample_id) %>% #group by genome
  summarise(total_abundance = sum(abundance, na.rm = TRUE), .groups = "drop") %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

x_limits = range(Overall_jaccard_expression_proxy_long$percent_water_content, na.rm = TRUE)
x_breaks = pretty(x_limits, n = 6)

OverallAbundRNA_plot = ggplot(Overall_jaccard_expression_proxy_long, aes(x = percent_water_content, y = total_abundance)) +
  geom_point(aes(fill = percent_water_content), shape = 21, color = "black", stroke = 0.2, size = 7, alpha = 1) +
  geom_smooth(aes(color = percent_water_content), method = "lm", se = FALSE, size = 1.1) +
  scale_fill_viridis_c(option = "mako", name = "Moisture Content (%)", labels = scales::percent_format(accuracy = 1)) + scale_colour_viridis_c(option = "mako", name = "Moisture Content (%)") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Total Expression (summed rpk abund. proxy)", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

OverallAbundRNA_plot

#ggsave(OverallAbundRNA_plot, file = "RNA_overall_abundproxy.pdf", height = 7, width = 7)

# Function to fit and test a linear model for each method
fit_and_test_lm_abundRNA = function(data) {
  lm_fit = lm(percent_water_content ~ total_abundance, data = data)
  tidy(lm_fit) %>%
    filter(term == "total_abundance")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_abundRNA_res = Overall_jaccard_expression_proxy_long %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_abundRNA)) %>%
  unnest(model_results)

###
### Now lets do the total number of active vOTUs per sample.
###

rna_num_abund_votus_persamps = rpk_metaT_rna_Overall %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "fullsample", values_to = "Abundance") %>%
  filter(Abundance > 0) %>%
  group_by(fullsample) %>%
  summarise(Abund_vOTUs = n_distinct(votu_id), .groups = 'drop') %>%
  mutate(sample = sub("_(MG|MT).*", "", fullsample)) %>%
  left_join(select(moisture_per_sample, sample, percent_water_content), by = "sample")

OverallActiveCountsRNA_plot = ggplot(rna_num_abund_votus_persamps, aes(x = percent_water_content, y = Abund_vOTUs)) +
  geom_point(aes(fill = percent_water_content), shape = 21, color = "black", stroke = 0.2, size = 7, alpha = 1) +
  geom_smooth(aes(color = percent_water_content), method = "lm", se = FALSE, size = 1.1) +
  scale_fill_viridis_c(option = "mako", name = "Moisture Content (%)", labels = scales::percent_format(accuracy = 1)) + scale_colour_viridis_c(option = "mako", name = "Moisture Content (%)") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Number of active vOTUs", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

OverallActiveCountsRNA_plot

#ggsave(OverallActiveCountsRNA_plot, file="RNA_ActiveCounts_Through_Moisture.pdf", height = 7, width = 7)

# Function to fit and test a linear model for each method
fit_and_test_lm_countsRNA = function(data) {
  lm_fit = lm(percent_water_content ~ Abund_vOTUs, data = data)
  tidy(lm_fit) %>%
    filter(term == "Abund_vOTUs")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_countsRNA_res = rna_num_abund_votus_persamps %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_countsRNA)) %>%
  unnest(model_results)

```

```{r prettier scatterplots}

variables_to_keep4 = c("moisture_per_sample", "metrics_combined", "metrics_combined_Full_DNA", "metrics_combined_Full_RNA", "rpk_metaT_dna_long", "expressed_otus_moisture") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep4)) #clean out the environment - keeping the metadata

# Reshape the data to gather richness, shannons, and pielous into a single column
metrics_combined_classed = metrics_combined %>%
  mutate(source = case_when(
    method %in% c("virome", "eukfloat", "bacterial", "total_dna") ~ "DNA",
    method %in% c("mt_virome", "mt_bulk", "mt_polya") ~ "RNA"
  ))

metrics_combined_classed = metrics_combined_classed %>%
  select(-c(6:8, 10:27))

metrics_combined_Full_DNA_simple = metrics_combined_Full_DNA %>%
  select(-c(5:7, 9:26)) %>%
  mutate(method = "full", source = "DNA") %>%
  select(sample_id, richness, shannons, pielous, method, percent_water_content, source)

metrics_combined_Full_RNA_simple = metrics_combined_Full_RNA %>%
  select(-c(5:7, 9:26)) %>%
  mutate(method = "full", source = "RNA") %>%
  select(sample_id, richness, shannons, pielous, method, percent_water_content, source)

metrics_combined_ALL = bind_rows(metrics_combined_classed, metrics_combined_Full_DNA_simple, metrics_combined_Full_RNA_simple)

metrics_long = metrics_combined_ALL %>%
  pivot_longer(cols = c(richness, shannons, pielous), 
               names_to = "metric", 
               values_to = "value")

# Z-scores per method × metric. go long
metrics_z = metrics_long %>%
  group_by(method, metric) %>%
  mutate(z = (value - mean(value, na.rm = TRUE)) / sd(value, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(metric = case_when(
    metric == "richness" ~ "Richness",
    metric == "shannons"  ~ "Shannon's H",
    metric == "pielous"   ~ "Pielou's J"
  ))

source_colors = c("virome" = "#73c5f6", "eukfloat" = "#f0704a", "bacterial" = "#54bc00", "total_dna" = "#ff7bac", "mt_virome" = "#c5b4c5" , "mt_bulk" = "#fedd8d", "mt_polya" = "#8ba494", "full" = "gray70")

# Final plot
zscored_diversity = ggplot(metrics_z, 
                            aes(x = percent_water_content, y = z)) +
  geom_hline(yintercept = 0, color = "gray70", size = 0.5) +
  geom_point(aes(fill = method), 
             shape = 21, 
             color = "black",
             stroke = 0.2, 
             size = 3.4,
             alpha = 0.5) +
  geom_smooth(aes(color = method), method = "lm", se = FALSE, size = 1.1) +
  facet_wrap(~ source + metric, ncol = 3) +
  scale_fill_manual(values = source_colors) +
  scale_color_manual(values = source_colors) +
  scale_x_continuous(labels = percent_format(accuracy = 1)) +
  labs(x = "Soil moisture content", y = "Z-score", fill = NULL, color = NULL) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 12),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(15, 15, 15, 15)
  ) +
  guides(fill = guide_legend(override.aes = list(size = 4, shape = 21, color = "black", stroke = 1.4), nrow = 1))

zscored_diversity

#ggsave(zscored_diversity, file = "zscored_diversity.pdf")

```

```{r ExpressionPatternsOverall}

variables_to_keep4 = c("moisture_per_sample", "metrics_combined", "metrics_combined_Full_DNA", "metrics_combined_Full_RNA", "rpk_metaT_dna_long", "expressed_otus_moisture") #All these vOTUs are a subset of this larger one, so keeping it in so i can subset it more easily.
rm(list=setdiff(ls(), variables_to_keep4)) #clean out the environment - keeping the metadata

#Alright so i really really like this. The only thing i think that this is missing is the overall expression patterns by method (i.e., total number of active vOTUs and total summed rpk expression). Let's read in this data. I'm going to read in tables that are the bulk metaT reads being mapped to the individual viruses from each method (both DNA and RNA). This is gonna be a doozy but i think it's going to be super cool. This will ask the qeuestionN: If I only had one of these methods and a bulk metaT, how would my interpretation be different?

#Bunch of datasests in here now so lets set up a function to do the normalization.

# Define a function for normalization
normalize_expression = function(counts_df) {
  normalized_counts = counts_df %>%
    filter(rowSums(select(., 7:19)) != 0) %>% #Remove rows where the sum of values in columns 7 to 19 is zero
    mutate(across(7:19, ~ ifelse(. < 5, 0, .))) %>% #Replace counts less than 5 with zero
    filter(rowSums(select(., 7:19)) != 0) %>% #Filter out completely zero rows again
    select(-Chr, -Start, -End, -Strand) %>% # Remove unnecessary columns
    column_to_rownames("Geneid")
  
  # Calculate RPK
  rpk_df = (normalized_counts[, 2:14] * 10^3) / normalized_counts[, 1] # Scale by kilobase pairs
  
  # Transform and summarize data in long format
  rpk_df_long = rpk_df %>%
    rownames_to_column(var = "votu_id") %>%
    pivot_longer(cols = -votu_id, names_to = "sample_id", values_to = "expression") %>% #long
    group_by(sample_id) %>%  #aggb per sample
    summarise(total_expression = sum(expression, na.rm = TRUE), .groups = "drop") %>% #now sum all of the values
    mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>% #and fix the base ids so i can left join moisture data
    left_join(moisture_per_sample, by = c("base_sample_id" = "sample")) #left join moisture
  
  return(rpk_df_long)
}

# read in all datasets
datasets = list(
  TotDNA_exp = read.delim("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/featureCounts_output_CDS_reverse-stranded_paired_TotDNA.txt", sep = "\t", header = T),
  VirDNA_exp = read.delim("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/featureCounts_output_CDS_reverse-stranded_paired_VirDNA.txt", sep = "\t", header = T),
  EukDNA_exp = read.delim("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/featureCounts_output_CDS_reverse-stranded_paired_Euk.txt", sep = "\t", header = T),
  BarDNA_exp = read.delim("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/featureCounts_output_CDS_reverse-stranded_paired_BAr.txt", sep = "\t", header = T)
)

# Apply normalization function to each dataset
normalized_results = lapply(datasets, normalize_expression)

# write these out. Going to treat these indedepently now just so i can handle a bit more.
TotDNA_rpk_norm = normalized_results[['TotDNA_exp']]
VirDNA_rpk_norm = normalized_results[['VirDNA_exp']]
EukDNA_rpk_norm = normalized_results[['EukDNA_exp']]
BarDNA_rpk_norm = normalized_results[['BarDNA_exp']]

#lets add in the method cols and ids so i can merge.
TotDNA_rpk_norm$method = "TotDNA"
VirDNA_rpk_norm$method = "VirDNA"
EukDNA_rpk_norm$method = "EukDNA"
BarDNA_rpk_norm$method = "BarDNA"

#bring in the overall from before
rpk_metaT_dna_long$method = "OverallDNA"

combined_DNA_expressions = rbind(TotDNA_rpk_norm, VirDNA_rpk_norm, EukDNA_rpk_norm, BarDNA_rpk_norm, rpk_metaT_dna_long)

combined_DNA_expressions_long = combined_DNA_expressions %>%
  select(c(sample_id, total_expression, method, percent_water_content))

# Z-scores per method × metric. go long
metrics_z_allCombinedDNA = combined_DNA_expressions_long %>%
  group_by(method) %>%
  mutate(z = (total_expression - mean(total_expression, na.rm = TRUE)) / sd(total_expression, na.rm = TRUE))

source_colors = c("VirDNA" = "#73c5f6", "EukDNA" = "#f0704a", "BarDNA" = "#54bc00", "TotDNA" = "#ff7bac", "OverallDNA" = "gray")

# Final plots
zscored_ExpressionPerMethodDNA = ggplot(metrics_z_allCombinedDNA, aes(x = percent_water_content, y = total_expression)) +
  geom_hline(yintercept = 0, color = "gray70", size = 0.5) +
  geom_point(aes(fill = method), shape = 21, color = "black", stroke = 0.2, size = 3.4, alpha = 0.5) +
  geom_smooth(aes(color = method), method = "lm", se = FALSE, size = 1.1) +
  scale_fill_manual(values = source_colors) +
  scale_color_manual(values = source_colors) +
  scale_x_continuous(labels = percent_format(accuracy = 1)) +
  labs(x = "Soil moisture content", y = "Z-score Expression", fill = NULL, color = NULL) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 12),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(15, 15, 15, 15)
  ) +
  guides(fill = guide_legend(override.aes = list(size = 4, shape = 21, color = "black", stroke = 1.4), nrow = 1)) +
  facet_wrap(~method, scales="free_y")

zscored_ExpressionPerMethodDNA

#ggsave(zscored_ExpressionPerMethodDNA, file = "non-zscored_Expression_v2.pdf", height = 6, width = 8)

# Filter data for OverallDNA
OverallDNA_data = metrics_z_allCombinedDNA %>% 
  filter(method == "OverallDNA")

# Filter data for the other methods
OtherMethods_data = metrics_z_allCombinedDNA %>% 
  filter(method %in% c("VirDNA", "EukDNA", "BarDNA", "TotDNA"))

x_limits = range(metrics_z_allCombinedDNA$percent_water_content, na.rm = TRUE)
x_breaks = pretty(x_limits, n = 6)

OverallDNA_plot = ggplot(OverallDNA_data, aes(x = percent_water_content, y = total_expression)) +
  geom_point(aes(fill = percent_water_content), shape = 21, color = "black", stroke = 0.2, size = 7, alpha = 1) +
  geom_smooth(aes(color = percent_water_content), method = "lm", se = FALSE, size = 1.1) +
  scale_fill_viridis_c(option = "mako", name = "Moisture Content (%)", labels = scales::percent_format(accuracy = 1)) + scale_colour_viridis_c(option = "mako", name = "Moisture Content (%)") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Total Summed Expression (rpk)", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

OverallDNA_plot
#ggsave(OverallDNA_plot, file = "overall_summed_expression.pdf", height = 7, width = 7)

#Now lets do the others
OtherMethods_plot = ggplot(OtherMethods_data, aes(x = percent_water_content, y = total_expression)) +
  geom_hline(yintercept = 0, color = "gray70", size = 0.5) +
  geom_point(aes(fill = method), shape = 21, color = "black", stroke = 0.2, size = 5, alpha = 1) +
  geom_smooth(aes(color = method), method = "lm", se = FALSE, size = 1.1) +
  scale_fill_manual(values = source_colors) +
  scale_color_manual(values = source_colors) +
  scale_x_continuous(labels = percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Total summed expression (rpk)", fill = "Method", color = "Method") +
  facet_wrap(~ method, scales = "free_y") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", strip.text = element_text(face = "bold", size = 12), panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_legend(override.aes = list(size = 4, shape = 21, color = "black", stroke = 1.4), nrow = 1))

OtherMethods_plot

#ggsave(OtherMethods_plot, file = "othermethods_summed_expression.pdf", height = 7, width = 7)

# Let's do some stats on these now.
fit_and_test_lm_expressDNA = function(data) {
  lm_fit = lm(percent_water_content ~ total_expression, data = data)
  tidy(lm_fit) %>%
    filter(term == "total_expression")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_expressDNA_res = OtherMethods_data %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_expressDNA)) %>%
  unnest(model_results)


#
# Now we have the values for summed rpk on DNA vOTUs. Let's do the vOTU counts now.
#

# I also want to do that for the number of active viruses. not the overall sum. so let's mod the function a bit and rerun.
count_active_votus = function(counts_df, moisture_per_sample = NULL) {
  
  active_counts = counts_df %>%
    filter(rowSums(select(., 7:19)) != 0) %>% #Remove rows that are zero across samples doingn this jsut so it runs faster sometimes a big deal
    mutate(across(7:19, ~ ifelse(. < 5, 0, .))) %>% #Set counts < 5 to zero
    filter(rowSums(select(., 7:19)) != 0) %>% #Remove rows that became all-zero after the threshold
    select(-Chr, -Start, -End, -Strand, -Length) %>% #remove bad cols i dont need
    column_to_rownames("Geneid")
  
  active_per_sample = active_counts %>%
    summarise(across(everything(), ~ sum(. > 0))) %>% # count active vOTUs per sample ie anything greater than zero
    pivot_longer(cols = everything(),
                 names_to = "sample_id",
                 values_to = "n_active_votus")
  
  # 6. Optional: add moisture info using the same base_sample_id logic you had
  if (!is.null(moisture_per_sample)) {
    active_per_sample = active_per_sample %>%
      mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
      left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))
  }
  
  return(active_per_sample)
}

active_votu_results = lapply(datasets, count_active_votus, moisture_per_sample = moisture_per_sample)

# Extract each one cleanly
TotDNA_active = active_votu_results[['TotDNA_exp']]
VirDNA_active = active_votu_results[['VirDNA_exp']]
EukDNA_active = active_votu_results[['EukDNA_exp']]
BarDNA_active = active_votu_results[['BarDNA_exp']]

#lets add in the method cols and ids so i can merge.
TotDNA_active$method = "TotDNA"
VirDNA_active$method = "VirDNA"
EukDNA_active$method = "EukDNA"
BarDNA_active$method = "BarDNA"

combined_DNA_expressions = rbind(TotDNA_active, VirDNA_active, EukDNA_active, BarDNA_active)

combined_DNA_expressions_simple = combined_DNA_expressions %>%
  select(sample_id, n_active_votus, percent_water_content, method)
  
#bring in the overall from before
expressed_otus_moisture$method = "OverallDNA" #match method
expressed_otus_moisture_renamed = expressed_otus_moisture %>%
  rename_with(~ "sample_id", .cols = matches("fullsample", ignore.case = TRUE)) %>%
  rename_with(~ "n_active_votus", .cols = matches("Expressed_OTUs", ignore.case = TRUE)) %>%
  select(sample_id, n_active_votus, percent_water_content, method)


combined_DNA_expressionCountsALL = rbind(combined_DNA_expressions_simple, expressed_otus_moisture_renamed)

# Z-scores per method × metric. go long
metrics_z_allCombbinedDNACounts = combined_DNA_expressionCountsALL %>%
  group_by(method) %>%
  mutate(z = (n_active_votus - mean(n_active_votus, na.rm = TRUE)) / sd(n_active_votus, na.rm = TRUE))

source_colors = c("VirDNA" = "#73c5f6", "EukDNA" = "#f0704a", "BarDNA" = "#54bc00", "TotDNA" = "#ff7bac", "OverallDNA" = "gray")

# Filter data for OverallDNA
OverallCombbinedDNACounts = metrics_z_allCombbinedDNACounts %>% 
  filter(method == "OverallDNA")

# Filter data for the other methods
OtherMethods_dataCounts = metrics_z_allCombbinedDNACounts %>% 
  filter(method %in% c("VirDNA", "EukDNA", "BarDNA", "TotDNA"))

x_limits = range(metrics_z_allCombbinedDNACounts$percent_water_content, na.rm = TRUE)
x_breaks = pretty(x_limits, n = 6)

OverallCountsDNA_plot = ggplot(OverallCombbinedDNACounts, aes(x = percent_water_content, y = n_active_votus)) +
  geom_point(aes(fill = percent_water_content), shape = 21, color = "black", stroke = 0.2, size = 7, alpha = 1) +
  geom_smooth(aes(color = percent_water_content), method = "lm", se = FALSE, size = 1.1) +
  scale_fill_viridis_c(option = "mako", name = "Moisture Content (%)", labels = scales::percent_format(accuracy = 1)) + scale_colour_viridis_c(option = "mako", name = "Moisture Content (%)") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Total Active vOTUs", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

OverallCountsDNA_plot
#ggsave(OverallCountsDNA_plot, file = "overall_Counts.pdf", height = 7, width = 7)

#Now lets do the others
OtherMethods_plot = ggplot(OtherMethods_dataCounts, aes(x = percent_water_content, y = n_active_votus)) +
  geom_hline(yintercept = 0, color = "gray70", size = 0.5) +
  geom_point(aes(fill = method), shape = 21, color = "black", stroke = 0.2, size = 5, alpha = 1) +
  geom_smooth(aes(color = method), method = "lm", se = FALSE, size = 1.1) +
  scale_fill_manual(values = source_colors) +
  scale_color_manual(values = source_colors) +
  scale_x_continuous(labels = percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Total Acive vOTUs", fill = "Method", color = "Method") +
  facet_wrap(~ method, scales = "free_y") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", strip.text = element_text(face = "bold", size = 12), panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_legend(override.aes = list(size = 4, shape = 21, color = "black", stroke = 1.4), nrow = 1))

OtherMethods_plot

#ggsave(OtherMethods_plot, file = "othermethods_counts.pdf", height = 7, width = 7)

# Let's do some stats on these now.
fit_and_test_lm_CountsDNA = function(data) {
  lm_fit = lm(percent_water_content ~ n_active_votus, data = data)
  tidy(lm_fit) %>%
    filter(term == "n_active_votus")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_expressDNA_res = OtherMethods_dataCounts %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_CountsDNA)) %>%
  unnest(model_results)

#

################

TotRNA_vals = read.delim("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/TotRNA_vOTU_output_abund_exp_parsed.tsv", sep = "\t", header = T, row.names = 1)

VirRNA_vals = read.delim("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/VirRNA_vOTU_output_abund_exp_parsed.tsv", sep = "\t", header = T, row.names = 1)

PolyaRNA_vals = read.delim("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/PolyA_vOTU_output_abund_exp_parsed.tsv", sep = "\t", header = T, row.names = 1)

#
#Start with TotRNA abundance
#

#lets split up abundance and expression
TotRNA_abundance = TotRNA_vals %>% 
  select(-contains("_rnaseq_expression")) %>%
  select(-scaffold_id, -length)

TotRNA_expression = TotRNA_vals %>% 
  select(contains("_rnaseq_expression"))

#this one is for left merging
Nonrelabund_rna_abundance_genome_Tot = TotRNA_abundance %>%
  rownames_to_column(var = "scaffold_id") %>%
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  filter(rowSums(.) != 0) %>% # Remove rows with zero across all samples
  rownames_to_column("scaffold_id") #too lazy to google the syntax

#Let's make the jaccardian matrix
jaccard_rna_expression_Tot = TotRNA_expression %>%
  rownames_to_column(var = "scaffold_id") %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0))) %>%
  filter(rowSums(.) != 0) %>% # Remove rows with zero across all samples
  rownames_to_column("scaffold_id")

#r is crap at indexinggggg readin out. writing back in.
#write.csv(Nonrelabund_rna_abundance_genome_Tot, file = "Nonrelabund_rna_abundance_genome_Tot.csv")
#write.csv(jaccard_rna_expression_Tot, file = "jaccard_rna_expression_Tot.csv")

Nonrelabund_jaccard_proxy_Tot = read.csv("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/processed_RNA_vOTU_tabs/overall/Updated_jaccard_proxy_nonrel_expression_Tot.csv", header = T, row.names = 1)

rpk_metaT_rna_Tot = ((Nonrelabund_jaccard_proxy_Tot[,2:14]*10^3)/Nonrelabund_jaccard_proxy_Tot[,1]) #note, we multiply by 10^3 here because geTMM expects kilobase pairs on lengths and featurecounts_dna_expression reports bps.

Tot_jaccard_expression_proxy_long = rpk_metaT_rna_Tot %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "sample_id", values_to = "abundance") %>%
  group_by(sample_id) %>% #group by genome
  summarise(total_abundance = sum(abundance, na.rm = TRUE), .groups = "drop") %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

x_limits = range(Tot_jaccard_expression_proxy_long$percent_water_content, na.rm = TRUE)
x_breaks = pretty(x_limits, n = 6)

TotAbundRNA_plot = ggplot(Tot_jaccard_expression_proxy_long, aes(x = percent_water_content, y = total_abundance)) +
  geom_point(shape = 21, fill = "#fedd8d", color = "black", stroke = 0.2, size = 14, alpha = 1) +
  geom_smooth(color = "#fedd8d", method = "lm", se = FALSE, size = 1.1) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Total Expression (summed rpk abund. proxy)", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

TotAbundRNA_plot

#ggsave(TotAbundRNA_plot, file = "RNA_Tot_abundproxy.pdf", height = 7, width = 8)

# Function to fit and test a linear model for each method
fit_and_test_lm_abundRNA = function(data) {
  lm_fit = lm(percent_water_content ~ total_abundance, data = data)
  tidy(lm_fit) %>%
    filter(term == "total_abundance")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_abundRNA_res = Tot_jaccard_expression_proxy_long %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_abundRNA)) %>%
  unnest(model_results)

###
### Now lets do the total number of active vOTUs per sample.
###

rna_num_abund_votus_persamps_Tot = rpk_metaT_rna_Tot %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "fullsample", values_to = "Abundance") %>%
  filter(Abundance > 0) %>%
  group_by(fullsample) %>%
  summarise(expressed_votus = n_distinct(votu_id), .groups = 'drop') %>%
  mutate(sample = sub("_(MG|MT).*", "", fullsample)) %>%
  left_join(select(moisture_per_sample, sample, percent_water_content), by = "sample")

TotActiveCountsRNA_plot = ggplot(rna_num_abund_votus_persamps_Tot, aes(x = percent_water_content, y = expressed_votus)) +
  geom_point(shape = 21, fill = "#fedd8d", color = "black", stroke = 0.2, size = 14, alpha = 1) +
  geom_smooth(color = "#fedd8d", method = "lm", se = FALSE, size = 1.1) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Total Expression (summed rpk abund. proxy)", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

TotActiveCountsRNA_plot

#ggsave(TotActiveCountsRNA_plot, file="RNA_ActiveCounts_Through_Moisture_Tot.pdf", height = 7, width = 8)

# Function to fit and test a linear model for each method
fit_and_test_lm_countsRNA = function(data) {
  lm_fit = lm(percent_water_content ~ expressed_votus, data = data)
  tidy(lm_fit) %>%
    filter(term == "expressed_votus")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_countsRNA_res_Tot = rna_num_abund_votus_persamps_Tot %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_countsRNA)) %>%
  unnest(model_results)

#


#
#Continue with VirRNA abundance
#

#lets split up abundance and expression
VirRNA_abundance = VirRNA_vals %>% 
  select(-contains("_rnaseq_expression")) %>%
  select(-scaffold_id, -length)

VirRNA_expression = VirRNA_vals %>% 
  select(contains("_rnaseq_expression"))

#this one is for left merging
Nonrelabund_rna_abundance_genome_Vir = VirRNA_abundance %>%
  rownames_to_column(var = "scaffold_id") %>%
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  filter(rowSums(.) != 0) %>% # Remove rows with zero across all samples
  rownames_to_column("scaffold_id") #too lazy to google the syntax

#Let's make the jaccardian matrix
jaccard_rna_expression_Vir = VirRNA_expression %>%
  rownames_to_column(var = "scaffold_id") %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0))) %>%
  filter(rowSums(.) != 0) %>% # Remove rows with zero across all samples
  rownames_to_column("scaffold_id")

#r is crap at indexinggggg readin out. writing back in.
#write.csv(Nonrelabund_rna_abundance_genome_Vir, file = "Nonrelabund_rna_abundance_genome_Vir.csv")

#write.csv(jaccard_rna_expression_Vir, file = "jaccard_rna_expression_Vir.csv")

Nonrelabund_jaccard_proxy_Vir = read.csv("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/processed_RNA_vOTU_tabs/Vir/Updated_jaccard_proxy_nonrel_expression_Vir.csv", header = T, row.names = 1)

rpk_metaT_rna_Vir = ((Nonrelabund_jaccard_proxy_Vir[,2:14]*10^3)/Nonrelabund_jaccard_proxy_Vir[,1]) #note, we multiply by 10^3 here because geTMM expects kilobase pairs on lengths and featurecounts_dna_expression reports bps.

Vir_jaccard_expression_proxy_long = rpk_metaT_rna_Vir %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "sample_id", values_to = "abundance") %>%
  group_by(sample_id) %>% #group by genome
  summarise(Viral_abundance = sum(abundance, na.rm = TRUE), .groups = "drop") %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

x_limits = range(Vir_jaccard_expression_proxy_long$percent_water_content, na.rm = TRUE)
x_breaks = pretty(x_limits, n = 6)

VirAbundRNA_plot = ggplot(Vir_jaccard_expression_proxy_long, aes(x = percent_water_content, y = Viral_abundance)) +
  geom_point(shape = 21, fill = "#c5b4c5", color = "black", stroke = 0.2, size = 14, alpha = 1) +
  geom_smooth(color = "#c5b4c5", method = "lm", se = FALSE, size = 1.1) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Viral Expression (summed rpk abund. proxy)", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

VirAbundRNA_plot

#ggsave(VirAbundRNA_plot, file = "RNA_Vir_abundproxy.pdf", height = 7, width = 8)

# Function to fit and test a linear model for each method
fit_and_test_lm_abundRNA = function(data) {
  lm_fit = lm(percent_water_content ~ Viral_abundance, data = data)
  tidy(lm_fit) %>%
    filter(term == "Viral_abundance")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_abundRNA_res = Vir_jaccard_expression_proxy_long %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_abundRNA)) %>%
  unnest(model_results)

###
### Now lets do the Viral number of active vOTUs per sample.
###

rna_num_abund_votus_persamps_Vir = rpk_metaT_rna_Vir %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "fullsample", values_to = "Abundance") %>%
  filter(Abundance > 0) %>%
  group_by(fullsample) %>%
  summarise(expressed_votus = n_distinct(votu_id), .groups = 'drop') %>%
  mutate(sample = sub("_(MG|MT).*", "", fullsample)) %>%
  left_join(select(moisture_per_sample, sample, percent_water_content), by = "sample")

VirActiveCountsRNA_plot = ggplot(rna_num_abund_votus_persamps_Vir, aes(x = percent_water_content, y = expressed_votus)) +
  geom_point(shape = 21, fill = "#c5b4c5", color = "black", stroke = 0.2, size = 14, alpha = 1) +
  geom_smooth(color = "#c5b4c5", method = "lm", se = FALSE, size = 1.1) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Viral Expression (summed rpk abund. proxy)", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

VirActiveCountsRNA_plot

#ggsave(VirActiveCountsRNA_plot, file="RNA_ActiveCounts_Through_Moisture_Vir.pdf", height = 7, width = 8)

# Function to fit and test a linear model for each method
fit_and_test_lm_countsRNA = function(data) {
  lm_fit = lm(percent_water_content ~ expressed_votus, data = data)
  tidy(lm_fit) %>%
    filter(term == "expressed_votus")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_countsRNA_res_Vir = rna_num_abund_votus_persamps_Vir %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_countsRNA)) %>%
  unnest(model_results)

#

#
#Continue with PolyaRNA abundance
#

#lets split up abundance and expression
PolyaRNA_abundance = PolyaRNA_vals %>% 
  select(-contains("_rnaseq_expression")) %>%
  select(-scaffold_id, -length)

PolyaRNA_expression = PolyaRNA_vals %>% 
  select(contains("_rnaseq_expression"))

#this one is for left merging
Nonrelabund_rna_abundance_genome_Polya = PolyaRNA_abundance %>%
  rownames_to_column(var = "scaffold_id") %>%
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  filter(rowSums(.) != 0) %>% # Remove rows with zero across all samples
  rownames_to_column("scaffold_id") #too lazy to google the syntax

#Let's make the jaccardian matrix
jaccard_rna_expression_Polya = PolyaRNA_expression %>%
  rownames_to_column(var = "scaffold_id") %>% #remove the noise
  group_by(scaffold_id) %>% #group by genome
  summarise(across(everything(), sum, na.rm = TRUE)) %>% #agg
  ungroup() %>%
  column_to_rownames("scaffold_id") %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0))) %>%
  filter(rowSums(.) != 0) %>% # Remove rows with zero across all samples
  rownames_to_column("scaffold_id")

#r is crap at indexinggggg readin out. writing back in.
#write.csv(Nonrelabund_rna_abundance_genome_Polya, file = "Nonrelabund_rna_abundance_genome_Polya.csv")

#write.csv(jaccard_rna_expression_Polya, file = "jaccard_rna_expression_Polya.csv")

Nonrelabund_jaccard_proxy_Polya = read.csv("/read_mapping_results/ecology_analyses/reads_from_metaT_to_vir_from_frac/processed_RNA_vOTU_tabs/PolyA/Updated_jaccard_proxy_nonrel_expression_Polya.csv", header = T, row.names = 1)

rpk_metaT_rna_Polya = ((Nonrelabund_jaccard_proxy_Polya[,2:14]*10^3)/Nonrelabund_jaccard_proxy_Polya[,1]) #note, we multiply by 10^3 here because geTMM expects kilobase pairs on lengths and featurecounts_dna_expression reports bps.

Polya_jaccard_expression_proxy_long = rpk_metaT_rna_Polya %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "sample_id", values_to = "abundance") %>%
  group_by(sample_id) %>% #group by genome
  summarise(Polyaal_abundance = sum(abundance, na.rm = TRUE), .groups = "drop") %>%
  mutate(base_sample_id = sub("_(MG|MT).*", "", sample_id)) %>%
  left_join(moisture_per_sample, by = c("base_sample_id" = "sample"))

x_limits = range(Polya_jaccard_expression_proxy_long$percent_water_content, na.rm = TRUE)
x_breaks = pretty(x_limits, n = 6)

PolyaAbundRNA_plot = ggplot(Polya_jaccard_expression_proxy_long, aes(x = percent_water_content, y = Polyaal_abundance)) +
  geom_point(shape = 21, fill = "#8ba494", color = "black", stroke = 0.2, size = 14, alpha = 1) +
  geom_smooth(color = "#8ba494", method = "lm", se = FALSE, size = 1.1) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Polyaal Expression (summed rpk abund. proxy)", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

PolyaAbundRNA_plot

#ggsave(PolyaAbundRNA_plot, file = "RNA_Polya_abundproxy.pdf", height = 7, width = 8)

# Function to fit and test a linear model for each method
fit_and_test_lm_abundRNA = function(data) {
  lm_fit = lm(percent_water_content ~ Polyaal_abundance, data = data)
  tidy(lm_fit) %>%
    filter(term == "Polyaal_abundance")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_abundRNA_res = Polya_jaccard_expression_proxy_long %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_abundRNA)) %>%
  unnest(model_results)

###
### Now lets do the Polyaal number of active vOTUs per sample.
###

rna_num_abund_votus_persamps_Polya = rpk_metaT_rna_Polya %>%
  rownames_to_column(var = "votu_id") %>%
  pivot_longer(cols = -votu_id, names_to = "fullsample", values_to = "Abundance") %>%
  filter(Abundance > 0) %>%
  group_by(fullsample) %>%
  summarise(expressed_votus = n_distinct(votu_id), .groups = 'drop') %>%
  mutate(sample = sub("_(MG|MT).*", "", fullsample)) %>%
  left_join(select(moisture_per_sample, sample, percent_water_content), by = "sample")

PolyaActiveCountsRNA_plot = ggplot(rna_num_abund_votus_persamps_Polya, aes(x = percent_water_content, y = expressed_votus)) +
  geom_point(shape = 21, fill = "#8ba494", color = "black", stroke = 0.2, size = 14, alpha = 1) +
  geom_smooth(color = "#8ba494", method = "lm", se = FALSE, size = 1.1) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = x_limits, breaks = x_breaks) +
  labs(x = "Soil moisture content", y = "Polyaal Expression (summed rpk abund. proxy)", fill = "Moisture content", color = NULL) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(15, 15, 15, 15)) +
  guides(fill = guide_colorbar(barwidth = 12, barheight = 0.8))

PolyaActiveCountsRNA_plot

#ggsave(PolyaActiveCountsRNA_plot, file="RNA_ActiveCounts_Through_Moisture_Polya.pdf", height = 7, width = 8)

# Function to fit and test a linear model for each method
fit_and_test_lm_countsRNA = function(data) {
  lm_fit = lm(percent_water_content ~ expressed_votus, data = data)
  tidy(lm_fit) %>%
    filter(term == "expressed_votus")  # Extract the statistical result for the slope (richness)
}

# Split the dataset by method, fit linear models, and collect results
fit_and_test_lm_countsRNA_res_Polya = rna_num_abund_votus_persamps_Polya %>%
  nest() %>%
  mutate(model_results = map(data, fit_and_test_lm_countsRNA)) %>%
  unnest(model_results)

#

```
